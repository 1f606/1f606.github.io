---
layout:     post
title:      webpack
subtitle:   
date:       2022-11-08
author:     
header-img: 
catalog: true
tags:
    - Webpack
---
# webpack

## 基本命令
```shell
#安装
npm install -D webpack webpack-cli
#打包
npx webpack
```

## Webpack打包流程
- 输入：从文件系统读入代码文件；
- 模块递归处理：调用 Loader 转译 Module 内容，并将结果转换为 AST，从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；
- 后处理：所有模块递归处理完毕后开始执行后处理，包括模块合并、注入运行时、产物优化等，最终输出 Chunk 集合；
- 输出：将 Chunk 写出到外部文件系统；

## webpack配置方式
- 单个配置对象：比较常用的一种方式，逻辑简单，适合大多数业务项目；
- 配置对象数组：每个数组项都是一个完整的配置对象，每个对象都会触发一次单独的构建，通常用于需要为同一份代码构建多种产物的场景，如 Library；
- 函数：Webpack 启动时会执行该函数获取配置，我们可以在函数中根据环境参数(如 NODE_ENV)动态调整配置对象。

### 数组方式
```javascript
// webpack.config.js
module.exports = [{
  name: 'amd',
  entry: './src/index.js',
  // 其它配置...
}, {
  entry: './src/index.js',
  // 其它配置...
}];
```
> 提示：使用配置数组时，还可以通过 --config-name 参数指定需要构建的配置对象，例如上例配置中若执行 npx webpack --config-name='amd'，则仅使用数组中 name='amd' 的项做构建。

### 函数方式
配置函数方式要求在配置文件中导出一个函数，并在函数中返回 Webpack 配置对象，或配置数组，或 Promise 对象，如：
```javascript
module.exports = function(env, argv) {
  // ...
  return {
    entry: './src/index.js',
    // 其它配置...
  }
}
```
运行时，Webpack 会传入两个环境参数对象：
- env：通过 --env 传递的命令行参数，适用于自定义参数，例如：

|命令：|env 参数值：|
|----|----|
|npx webpack --env prod|{ prod: true }|
|npx webpack --env prod --env min|{ prod: true, min: true }|
|npx webpack --env platform=app --env production|{ platform: "app", production: true }|
|npx webpack --env foo=bar=app|{foo: "bar=app"}|
|npx webpack --env app.platform="staging" --env app.name="test"|npx webpack --env app.platform="staging" --env app.name="test"|

- argv：命令行 [Flags](https://webpack.js.org/api/cli/#flags) 参数，支持 entry/output-path/mode/merge 等。

## babel
Webpack 场景下，只需使用 babel-loader 即可接入 Babel 转译功能。将高版本语法转换为兼容性更强的低版本语法或 polyfill。

Preset 是 Babel 的主要应用方式之一，不同应用场景有不同 Preset 资源。

### 常用babel插件
@babel/preset-env 是一种 Babel 预设规则集，内置了一系列polyfill、插件等。

@babel/core是babel转码的核心依赖。

### 配置方式
可以使用 `.babelrc` 文件或 `rule.options` 属性配置 Babel 功能逻辑，例如：
```javascript
module.exports = {
  /* ... */
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'babel-loader',
            options: {
              presets: ['@babel/preset-env']
            }
          }
        ]
      }
    ]
  }
};
```

## typescript
Webpack 有很多种接入 TypeScript 的方法，包括 ts-loader、awesome-ts-loader、 babel-loader+@babel/preset-typescript。

### 引入ts-loader
通常可使用 ts-loader 构建 TypeScript 代码。
```shell
npm i -D typescript ts-loader
```

```javascript
const path = require('path');

module.exports = {
  /* xxx */
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: 'ts-loader'
      },
    ],
  },
  resolve: {
    extensions: ['.ts', '.js'],
  }
};
```

```java
//tsconfig.json
{
  "compilerOptions": {
    "noImplicitAny": true,
    "moduleResolution": "node"
  }
}
```

### 和babel-loader搭配使用
如果项目中已经使用 babel-loader，你也可以选择使用 @babel/preset-typescript 规则集，借助 babel-loader 完成 JavaScript 与 TypeScript 的转码工作。

```shell
npm i -D @babel/preset-typescript
```

```javascript
module.exports = {
  /* ... */
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'babel-loader',
            options: {
              presets: ['@babel/preset-typescript']
            }
          }
        ]
      }
    ]
  }
};
```

注意：@babel/preset-typescript 只是简单完成代码转换，并未做类似 ts-loader 的类型检查工作。

## eslint
在 Webpack 中，可以使用 eslint-webpack-plugin 接入 ESLint 工具

```shell
npm install -D webpack webpack-cli

npm install --save-dev eslint eslint-webpack-plugin eslint-config-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-n
```

.eslintrc文件配置
```json
{
  "extends": "standard"
}
```

webpack配置
```javascript
const ESLintPlugin = require('eslint-webpack-plugin')
module.exports = {
  plugins: [new ESLintPlugin()]
}
```

## eslint+typescript+babel
```shell
npm i -D webpack webpack-cli \
    # babel 依赖
    @babel/core @babel/cli @babel/preset-env babel-loader \
    # TypeScript 依赖
    typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin \
    @babel/preset-typescript \
    # ESLint 依赖
    eslint eslint-webpack-plugin
```
.eslintrc配置
```json
{
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "extends": ["plugin:@typescript-eslint/recommended"]
}
```
```javascript
module.exports = {
  // ...
  plugins: [new ESLintPlugin({ extensions: ['.js', '.ts'] })]
}
```
## 处理样式
常用loader或plugin：
- css-loader：该 Loader 会将 CSS 等价翻译为形如 module.exports = "${css}" 的JavaScript 代码，使得 Webpack 能够如同处理 JS 代码一样解析 CSS 内容与资源依赖；
- style-loader：该 Loader 将在产物中注入一系列 runtime 代码，这些代码会将 CSS 内容注入到页面的 style 标签，使得样式生效；
- mini-css-extract-plugin：该插件会将 CSS 代码抽离到单独的 .css 文件，并将文件通过 <link> 标签方式插入到页面中。提供 Loader、Plugin 组件，需要同时使用。

### css-loader+style-loader
问题：
- JS、CSS 资源无法并行加载，从而降低页面性能；
- 资源缓存粒度变大，JS、CSS 任意一种变更都会致使缓存失效。

### css-loader + mini-css-extract-plugin
```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const HTMLWebpackPlugin = require('html-webpack-plugin')

module.exports = {
    module: {
        rules: [{
            test: /\.css$/,
            use: [
                (process.env.NODE_ENV === 'development' ?
                    'style-loader' :
                    MiniCssExtractPlugin.loader),
                'css-loader'
            ]
        }]
    },
    plugins: [
        new MiniCssExtractPlugin(),
        new HTMLWebpackPlugin()
    ]
}
```
### 预处理器
在rules的use数组里的css-loader后加上对应预处理器的loader。
```javascript
module.exports = {
    module: {
        rules: [{
            use: [
                'css-loader', 
              // 预处理器loader
            ]
        }]
    }
}
```
#### postcss
postcss的使用除了postcss postcss-loader的安装外，还需要对应postcss的插件。例如我们可以使用 autoprefixer 插件自动添加浏览器前缀、[postcss-preset-env](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjonathantneal%2Fpostcss-preset-env)转译为兼容性更好的代码。
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          "style-loader", 
          {
            loader: "css-loader",            
            options: {
              importLoaders: 1
            }
          }, 
          {
            loader: "postcss-loader",
            options: {
              postcssOptions: {
                // 添加 autoprefixer 插件
                plugins: [require("autoprefixer")],
              },
            },
          }
          // 或在postcss.config.js配置
          // postcss-loader
        ],
      },
    ],
  }
};
```
## vue项目环境搭建
### 安装vue
```shell
#两个版本要一致
npm i vue
npm i -D vue-template-compiler
```
### vue-loader处理sfc
vue-loader 库同时提供用于处理 SFC 代码转译的 Loader 组件，与用于处理上下文兼容性的 Plugin 组件，两者需要同时配置才能正常运行。
> vue-loader高版本不处理vue2，需要16以下版本

```javascript
const { VueLoaderPlugin } = require("vue-loader");

module.exports = {
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: ["vue-loader"],
      },
    ],
  },
  plugins: [new VueLoaderPlugin()],
};
```
但是sfc里面的style还是需要style-loader和css-loader处理
```javascript
module.exports = {
  rules: [
    // ...
    {
      test: /\.css$/,
      use: ["style-loader", "css-loader"],
    }
  ]
}
```
### HtmlWebpackPlugin生成入口HTML
```shell
yarn add -D html-webpack-plugin
```
```javascript
module.exports = {
  plugins: [
    // ...
    new HtmlWebpackPlugin({
      templateContent: `
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Webpack App</title>
  </head>
  <body>
    <div id="app" />
  </body>
</html>
    `,
    })
  ]
}
```
### webpack-dev-server启动本地开发服务
```shell
npm install -D webpack-dev-server
```
```javascript
module.exports = {
  devServer: {
    hot: true,
    open: true
  }
}
```
```shell
#启动服务
npx webpack serve
```
### sfc加入typescript
```shell
npm install -D typescript ts-loader
```
```javascript
module.exports = {
  rules: [
    // ...
    { test: /\.ts$/, use: ["ts-loader"] }
  ]
}
```
sfc的script标签设置lang = "typescript"。

vue-loader 会根据 lang 属性值，按 Webpack 配置的 TypeScript 规则，调用 ts-loader 处理这部分代码。支持tsconfig.json
> 同理，与处理普通 .ts、.js 文件类似的，我们还可以通过 Webpack 的 module.rule 配置项继续接入 ESLint、Babel、Flow 等工具，这些规则也都会对 Vue SFC 文件模块生效。

### sfc template处理
template的处理规则会稍微不同，因为绝大部分 Webpack 模板类 Loader 都会返回一个模板函数，而不是编译好的 HTML 片段，这与 Vue SFC 将template编译为 render 函数的规则相冲突，此时通常需要使用一个返回原始的 HTML 字符串的 loader，例如使用 pug-plain-loader，而不是 pug-loader。
```shell
yarn add -D pug pug-plain-loader
```
```javascript
module.exports = {
  rules: [
    // ...
    { test: /\.pug$/, use: ["pug-plain-loader"] },
  ]
}
```
设置 template 标签的 lang = " pug"。
## externals peerDependencies
将第三方依赖排除在打包系统之外，避免出现使用者在业务项目中已经安装并使用了该第三方依赖，那么最终产物必然会包含两份第三方依赖代码。

[webpack-node-externals](https://www.npmjs.com/package/webpack-node-externals) 可以排除所有 node_modules 模块，使用方法：
```javascript
// webpack.config.js
const nodeExternals = require('webpack-node-externals');

module.exports = {
  // ...
  externals: [nodeExternals()]
  // ...
};
```
## npm库配置技巧
- 使用 .npmignore 文件忽略不需要发布到 NPM 的文件；
- 在 package.json 文件中，使用 prepublishOnly 指令，在发布前自动执行编译命令，例如：

```json
{
  "scripts": {
    "prepublishOnly": "webpack --mode=production"
  }
}
```
## 如何搭建 React 全栈开发环境？
## 使用 Webpack 构建微前端应用
## 如何借助 Webpack 开发 PWA、Node、Electron 应用？
## 图片
### 打包
#### webpack4
file-loader：将图像引用转换为 url 语句并生成相应图片文件，例如使用如下配置：
```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      use: ['file-loader']
    }],
  },
};
```
url-loader：有两种表现，对于小于阈值 limit 的图像直接转化为 base64 编码；大于阈值的图像则调用 file-loader 进行加载，例如如下配置：
```javascript
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      use: [{
        loader: 'url-loader',
        options: {
          // 单位 B
          limit: 1024
        }
      }]
    }],
  },
};
```
raw-loader：不做任何转译，只是简单将文件内容复制到产物中，适用于 SVG 场景，例如如下配置：
```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.svg$/i,
        use: ['raw-loader'],
      },
    ],
  },
};
```
#### webpack5
内置了[资源模块](https://webpack.js.org/guides/asset-modules/)，不再需要安装上述loader。
### 压缩
在 Webpack 生态中有不少优秀的图像压缩组件，包括：image-webpack-loader、imagemin-webpack-plugin、image-minimizer-webpack-plugin 等，以我的使用经验来看，image-webpack-loader 组件功能齐全且用法简单，更推荐使用。基本用法首先安装依赖：
```javascript
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(gif|png|jpe?g|svg)$/i,
      type: "asset/resource",
      use: [{
        loader: 'image-webpack-loader',
        options: {
          // jpeg 压缩配置
          mozjpeg: {
            quality: 80
          },
        }
      }]
    }],
  },
};
```
image-webpack-loader 底层依赖于 imagemin 及一系列的图像优化工具：
- mozjpeg：用于压缩 JPG(JPEG) 图片；
- optipng：用于压缩 PNG 图片；
- pngquant：同样用于压缩 PNG 图片；
- svgo：用于压缩 SVG 图片；
- gifsicle：用于压缩 Gif 图；
- webp：用于将 JPG/PNG 图压缩并转化为 WebP 图片格式。

注意：图像压缩是一种非常耗时的操作。
### 雪碧图
Webpack 中，我们可以使用 webpack-spritesmith 插件自动实现雪碧图效果。HTTP2 实现 TCP 多路复用之后，雪碧图的优化效果已经微乎其微。
### 响应式图片
为不同设备提供不同的分辨率、不同尺寸的图片，兼顾显示效果和带宽。
Webpack 中有不少能够自动生成响应式图片的组件，例如： resize-image-loader、html-loader-srcset、responsive-loader 等，以 responsive-loader 为例，首先安装依赖：
```shell
yarn add -D responsive-loader sharp
```
```javascript
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      oneOf: [{
        type: "javascript/auto",
        // 过滤出带 size/sizes 参数的图片引用
        resourceQuery: /sizes?/,
        use: [{
          loader: "responsive-loader",
          options: {
            adapter: require("responsive-loader/sharp"),
          },
        }],
      }, {
        type: "asset/resource",
      }],
    }],
  }
};
```

## 性能分析
```javascript
// webpack.config.js
module.exports = {
  // ...
  profile: true
}
```
--json 参数，参数值为最终生成的统计文件名，执行后会生成stats.json文件。
```shell
npx webpack --json=stats.json
```
社区提供的部分优秀分析工具：
- Webpack Analysis ：Webpack 官方提供的，功能比较全面的 stats 可视化工具。
- Statoscope：主要侧重于模块与模块、模块与 chunk、chunk 与 chunk 等，实体之间的关系分析。
- Webpack Visualizer：一个简单的模块体积分析工具，真的很简单！
- Webpack Bundle Analyzer：应该是使用率最高的性能分析工具之一，主要实现以 Tree Map 方式展示各个模块的体积占比。
- Webpack Dashboard：能够在编译过程实时展示编译进度、模块分布、产物信息等。
- Unused Webpack Plugin：能够根据 stats 数据反向查找项目中未被使用的文件。
- Speed Measure Plugin：能够统计出各个 Loader、插件的处理耗时，开发者可以根据这些数据分析出哪些类型的文件处理更耗时间。

## 持久化缓存
### webpack5
https://webpack.js.org/configuration/cache/
### webpack4
原生不支持，只能借助第三方：
- 使用 [cache-loader](https://www.npmjs.com/package/cache-loader)；
- 使用 [hard-source-webpack-plugin](https://github.com/mzgoddard/hard-source-webpack-plugin)；
- 使用 Loader（如 babel-loader、eslint-loader)）自带的缓存能力。

#### cache-loader
仅缓存了 Loader 执行结果。
```shell
yarn add -D cache
```
cache-loader必须在首位。
```javascript
module.exports = {
    // ...
    module: {
        rules: [{
            test: /\.js$/,
            use: ['cache-loader', 'babel-loader', 'eslint-loader']
        }]
    },
    // ...
};
```
#### hard-source-webpack-plugin
不仅仅缓存了 Loader 运行结果，还保存了 Webpack 构建过程中许多中间数据，包括：模块、模块关系、模块 Resolve 结果、Chunks、Assets 等，效果几乎与 Webpack5 自带的 Cache 对齐。

首次运行时，hard-source-webpack-plugin 会在缓存文件夹 node_module/.cache 写入一系列日志文件。
```shell
yarn add -D hard-source-webpack-plugin
```
```javascript
const HardSourceWebpackPlugin = require("hard-source-webpack-plugin");

module.exports = {
  // ...
  plugins: [
    new HardSourceWebpackPlugin(),
  ],
};
```

### 组件自带的缓存能力
还可以使用 Webpack 组件自带的缓存能力提升特定领域的编译性能，这一类组件有：
- babel-loader；
- eslint-loader：旧版本 ESLint Webpack 组件，官方推荐使用 eslint-webpack-plugin 代替；
- eslint-webpack-plugin；
- stylelint-webpack-plugin。

cacheDirectory = true开启。默认情况下，缓存内容会被保存到 node_modules/.cache/babel-loader 目录，你也可以通过 cacheDirectory = 'dir' 属性设置缓存路径。
```javascript
module.exports = {
    // ...
    module: {
        rules: [{
            test: /\.m?js$/,
            loader: 'babel-loader',
            options: {
                cacheDirectory: true,
            },
        }]
    },
    // ...
};
```
ESLint 与 Stylelint 也提供了相应的缓存能力，设置 cache = true 可开启。
```javascript
// webpack.config.js
module.exports = {
  plugins: [
    new ESLintPlugin({ cache: true }),
    new StylelintPlugin({ files: '**/*.css', cache: true }),
  ],
};
```

## 并行构建
### happyPack
HappyPack 能够将耗时的文件加载（Loader）操作拆散到多个子进程中并发执行，子进程执行完毕后再将结果合并回传到 Webpack 进程，从而提升构建性能。
不过，HappyPack 的用法稍微有点难以理解，需要同时：

- 使用 happypack/loader 代替原本的 Loader 序列；
- 使用 HappyPack 插件注入代理执行 Loader 序列的逻辑。

```shell
yarn add -D happypack
```
将原有 loader 配置替换为 happypack/loader，如：
```javascript
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: "happypack/loader",
        // 原始配置如：
        // use: [
        //  {
        //      loader: 'babel-loader',
        //      options: {
        //          presets: ['@babel/preset-env']
        //      }
        //  },
        //  'eslint-loader'
        // ]
      },
    ],
  },
};
```
创建 happypack 插件实例，并将原有 loader 配置迁移到插件中，完整配置：
```javascript
const HappyPack = require("happypack");

module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: "happypack/loader",
        // 原始配置如：
        // use: [
        //  {
        //      loader: 'babel-loader',
        //      options: {
        //          presets: ['@babel/preset-env']
        //      }
        //  },
        //  'eslint-loader'
        // ]
      },
    ],
  },
  plugins: [
    new HappyPack({
      // 将原本定义在 `module.rules.use` 中的 Loader 配置迁移到 HappyPack 实例中
      loaders: [
        {
          loader: "babel-loader",
          option: {
            presets: ["@babel/preset-env"],
          },
        },
        "eslint-loader",
      ],
    }),
  ],
};
```
HappyPack支持创建多个实例来加载多种类型，例如：
```javascript
const HappyPack = require('happypack');

module.exports = {
  // ...
  module: {
    rules: [{
        test: /\.js?$/,
        // 使用 `id` 参数标识该 Loader 对应的 HappyPack 插件示例
        use: 'happypack/loader?id=js'
      },
      {
        test: /\.less$/,
        use: 'happypack/loader?id=styles'
      },
    ]
  },
  plugins: [
    new HappyPack({
      // 注意这里要明确提供 id 属性
      id: 'js',
      loaders: ['babel-loader', 'eslint-loader']
    }),
    new HappyPack({
      id: 'styles',
      loaders: ['style-loader', 'css-loader', 'less-loader']
    })
  ]
};
```
上面这种多实例模式虽然能应对多种类型资源的加载需求，但默认情况下反而会带来新的性能损耗。

为此，HappyPack 提供了一套简单易用的共享进程池接口，只需要创建 HappyPack.ThreadPool 对象，并通过 size 参数限定进程总量，之后将该例配置到各个 HappyPack 插件的 threadPool 属性上即可，例如：
```js
const os = require('os')
const HappyPack = require('happypack');
const happyThreadPool = HappyPack.ThreadPool({
  // 设置进程池大小
  size: os.cpus().length - 1
});

module.exports = {
  // ...
  plugins: [
    new HappyPack({
      id: 'js',
      // 设置共享进程池
      threadPool: happyThreadPool,
      loaders: ['babel-loader', 'eslint-loader']
    }),
    new HappyPack({
      id: 'styles',
      threadPool: happyThreadPool,
      loaders: ['style-loader', 'css-loader', 'less-loader']
    })
  ]
};
```
使用 HappyPack.ThreadPool 接口后，HappyPack 会预先创建好一组工作进程，所有插件实例的资源转译任务会通过内置的 HappyThread 对象转发到空闲进程做处理，避免频繁创建、销毁进程。

核心步骤：
- happlypack/loader 接受到转译请求后，从 Webpack 配置中读取出相应 HappyPack 插件实例；
- 调用插件实例的 compile 方法，创建 HappyThread 实例（或从 HappyThreadPool 取出空闲实例）；
- HappyThread 内部调用 child_process.fork 创建子进程，并执行HappyWorkerChannel 文件；
- HappyWorkerChannel 创建 HappyWorker ，开始执行 Loader 转译逻辑；

#### 缺点
作者不再维护；HappyPack 自己实现的加载器逻辑可能有兼容性问题；其主要用于文件加载阶段，并不会影响后续的产物生成、合并、优化等功能，性能收益有限。

### Thread-loader
Thread-loader 与 HappyPack 功能类似，都是以多进程方式加载文件的 Webpack 组件，两者主要区别：
持续迭代；用法简单；
HappyPack 启动后会创建一套 Mock 上下文环境 —— 包含 emitFile 等接口，并传递给 Loader，因此对大多数 Loader 来说，运行在 HappyPack 与运行在 Webpack 原生环境相比没有太大差异；但 Thread-loader 并不具备这一特性，所以要求 Loader 内不能调用特定上下文接口，兼容性较差。
```shell
#安装
yarn add -D thread-loader
```
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        // 放在 use 数组首位，确保最先运行
        use: ["thread-loader", "babel-loader", "eslint-loader"],
      },
      // 配置对象
      {
        test: /\.js$/,
        use: [
          {
            loader: "thread-loader",
            options: {
              workers: 2,
              workerParallelJobs: 50,
              // ...
            },
          },
          "babel-loader",
          "eslint-loader",
        ],
      }
    ],
  },
};
```

启动后，Thread-loader 会在加载文件时创建新的进程，在子进程中使用 loader-runner 库运行 thread-loader 之后的 Loader 组件，执行完毕后再将结果回传到 Webpack 主进程，从而实现性能更佳的文件加载转译效果。

不过，Thread-loader 也同样面临着频繁的子进程创建、销毁所带来的性能问题，为此，Thread-loader 提供了 warmup 接口用于前置创建若干工作子进程，降低构建时延，用法：
```javascript
const threadLoader = require("thread-loader");

threadLoader.warmup(
  {
    // 可传入上述 thread-loader 参数
    workers: 2,
    workerParallelJobs: 50,
  },
  [
    // 子进程中需要预加载的 node 模块
    "babel-loader",
    "babel-preset-es2015",
    "sass-loader",
  ]
);
```
#### 缺点
- 在 Thread-loader 中运行的 Loader 不能调用 emitAsset 等接口，这会导致 style-loader 这一类加载器无法正常工作，解决方案是将这类组件放置在 thread-loader 之前，如 ['style-loader', 'thread-loader', 'css-loader']；
- Loader 中不能获取 compilation、compiler 等实例对象，也无法获取 Webpack 配置。

这会导致一些 Loader 无法与 Thread-loader 共同使用

### Parallel-Webpack
Thread-loader、HappyPack 这类组件所提供的并行能力都仅作用于文件加载过程，对后续 AST 解析、依赖收集、打包、优化代码等过程均没有影响，理论收益还是比较有限的。

```shell
yarn add -D parallel-webpack

#使用
npx parallel-webpack
```
```javascript
module.exports = [{
    entry: 'pageA.js',
    output: {
        path: './dist',
        filename: 'pageA.js'
    }
}, {
    entry: 'pageB.js',
    output: {
        path: './dist',
        filename: 'pageB.js'
    }
}];
```

Parallel-Webpack 会为配置文件中导出的每个 Webpack 配置对象启动一个独立的构建进程，从而实现并行编译的效果。底层原理很简单，基本上就是在 Webpack 上套了个壳：

- 根据传入的配置项数量，调用 worker-farm 创建复数个工作进程；
- 工作进程内调用 Webpack 执行构建；
- 工作进程执行完毕后，调用 node-ipc 向主进程发送结束信号。

这种方式在需要同时执行多份配置的编译时特别有效，但若配置文件本身只是导出了单个配置对象则意义不大。

为了更好地支持多种配置的编译，Parallel-Webpack 还提供了 createVariants 函数，用于根据给定变量组合，生成多份 Webpack 配置对象，如：
```javascript
const createVariants = require('parallel-webpack').createVariants
const webpack = require('webpack')

const baseOptions = {
  entry: './index.js'
}

// 配置变量组合
// 属性名为 webpack 配置属性；属性值为可选的变量
// 下述变量组合将最终产生 2*2*4 = 16 种形态的配置对象
const variants = {
  minified: [true, false],
  debug: [true, false],
  target: ['commonjs2', 'var', 'umd', 'amd']
}

function createConfig (options) {
  const plugins = [
    new webpack.DefinePlugin({
      DEBUG: JSON.stringify(JSON.parse(options.debug))
    })
  ]
  return {
    output: {
      path: './dist/',
      filename: 'MyLib.' +
                options.target +
                (options.minified ? '.min' : '') +
                (options.debug ? '.debug' : '') +
                '.js'
    },
    plugins: plugins
  }
}

module.exports = createVariants(baseOptions, variants, createConfig)
```

虽然，parallel-webpack 相对于 Thread-loader、HappyPack 有更高的并行度，但进程实例之间并没有做任何形式的通讯，这可能导致相同的工作在不同进程 —— 或者说不同 CPU 核上被重复执行。

例如需要对同一份代码同时打包出压缩和非压缩版本时，在 parallel-webpack 方案下，前置的资源加载、依赖解析、AST 分析等操作会被重复执行，仅仅最终阶段生成代码时有所差异。

这种技术实现，对单 entry 的项目没有任何收益，只会徒增进程创建成本；但特别适合 MPA 等多 entry 场景，或者需要同时编译出 esm、umd、amd 等多种产物形态的类库场景。

## 并行压缩
Webpack4 默认使用 [Uglify-js](https://www.npmjs.com/package/uglifyjs-webpack-plugin) 实现代码压缩，Webpack5 之后则升级为 [Terser](https://webpack.js.org/plugins/terser-webpack-plugin/) —— 一种性能与兼容性更好的 JavaScript 代码压缩混淆工具，两种组件都原生实现了多进程并行压缩能力。

以 Terser 为例，TerserWebpackPlugin 插件默认已开启并行压缩，开发者也可以通过 parallel 参数（默认值为 require('os').cpus() - 1）设置具体的并发进程数量，如：
```javascript
const TerserPlugin = require("terser-webpack-plugin");

module.exports = {
    optimization: {
        minimize: true,
        minimizer: [new TerserPlugin({
            parallel: 2 // number | boolean
        })],
    },
};
```
上述配置即可设定最大并行进程数为 2。此外，Webpack4 所使用的 uglifyjs-webpack-plugin 也提供了类似的功能，用法与 Terser 相同。

理论上，并行确实能够提升系统运行效率，但 Node 单线程架构下，所谓的并行计算都只能依托与派生子进程执行，而创建进程这个动作本身就有不小的消耗 —— 大约 600ms，对于小型项目，构建成本可能可能很低，引入多进程技术反而导致整体成本增加，因此建议大家按实际需求斟酌使用上述多进程方案。

## 构建性能优化技巧
1. 使用最新版本的webpack、使用新特性。
2. 约束 Loader 执行范围。因为 Loader 在执行内容转换的过程中可能需要比较密集的 CPU 运算。通常可以排除 node_module 文件夹。
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /.js$/,
        exclude: /node_modules/,
        use: ['babel-loader', 'eslint-loader']
      }
    ]
  }
}
```
3. 使用module.noParse跳过提前打包处理过的文件的编译。

注意：
- 由于跳过了前置的 AST 分析动作，构建过程无法发现文件中可能存在的语法错误，需要到运行（或 Terser 做压缩）时才能发现问题，所以必须确保 noParse 的文件内容正确性。
- 由于跳过了依赖分析的过程，所以文件中，建议不要包含 import/export/require/define 等模块导入导出语句 —— 换句话说，noParse 文件不能存在对其它文件的依赖，除非运行环境支持这种模块化方案。
- 由于跳过了内容分析过程，Webpack 无法标记该文件的导出值，也就无法实现 Tree-shaking。

例如：

React@18 默认定义的导出文件是 index.js。
```json
{
  "main": "index.js"
}
```
但 node_module/react/index.js 文件包含了模块导入语句 require：
```js
if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = require('./cjs/react.development.js');
}
```
此时，真正有效的代码被包含在 react.development.js（或 react.production.min.js）中，但 Webpack 只会打包这段 index.js 内容，
也就造成了产物中实际上并没有真正包含 React。针对这个问题，我们可以先找到适用的代码文件，然后用 resolve.alias 配置项重定向到该文件：
```javascript
module.exports = {
  module: {
    noParse: /react|lodash/,
    resolve: {
      alias: {
        react: path.join(__dirname,
          process.env.NODE_ENV === 'production'
          ? './node modules/react/cjs/react.production.min.js' 
          :  './node modules/react/cjs/react.development.js'
        )
      }
    }
  }
}
```
提示：使用 externals 也能将部分依赖放到构建体系之外，实现与 noParse 类似的效果，详情可查阅官网。
4. 开发模式禁用产物优化
Webpack 提供了许多产物优化功能，例如：Tree-Shaking、SplitChunks、Minimizer 等，这些能力能够有效减少最终产物的尺寸，
提升生产环境下的运行性能，但这些优化在开发环境中意义不大，反而会增加构建器的负担(都是性能大户)。

最终，建议开发环境配置如：
```javascript
module.exports = {
  mode: 'development',
  optimization: {
    // 移除已存在在所有父级模块中的模块
    removeAvailableModules: false,
    // 移除空模块
    removeEmptyChunks: false,
    // 关闭代码分包
    splitChunks: false,
    // 关闭代码压缩
    minmize: false,
    // 关闭模块合并
    concatenateModules: false,
    // 关闭 Tree-shaking 功能
    usedExports: false
  }
}
```
5. 最小化 watch 范围
在 watch 模式下（通过 npx webpack --watch 命令启动），Webpack 会持续监听项目目录中所有代码文件，
发生变化时执行 rebuild 命令。前端项目中部分资源并不会频繁更新，例如 node_modules，所以最小化 watch 范围能提高性能。
```javascript
module.exports = {
  watchOptions: {
    ignored: /node_modules/
  }
}
```
6. 跳过 TS 类型检查
类型检查涉及 AST 解析、遍历以及其它非常消耗 CPU 的操作，会给工程化流程带来比较大的性能负担，因此我们可以选择关闭 ts-loader 的类型检查功能：
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /.ts$/,
        use: [
          {
            loader: 'ts-loader',
            options: {
              // 设置为仅编译，关闭类型检查
              transpileOnly: true
            }
          }
        ]
      }
    ]
  }
}
```
然后我们可以用过以下步骤实现类型检查：
- 可以借助编辑器的 TypeScript 插件实现代码检查
- 使用 fork-ts-checker-webpack-plugin 插件将类型检查能力剥离到 子进程 执行，例如：

```javascript
const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');

module.exports = {
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: [
          {
            loader: 'ts-loader',
            options: {
              transpileOnly: true
            }
          }
        ]
      }
    ]
  },
  plugins: [
    // 用于执行类型检查
    new ForkTsCheckerWebpackPlugin()
  ]
}
```
这样，既可以获得 Typescript 静态类型检查能力，又能提升整体编译速度。
7. 优化 ESLint 性能
使用 eslint-loader 实现实时代码检查，会带来比较高昂且不必要的性能成本，我们可以选择其它更聪明的方式接入 ESLint。

例如，使用新版本组件 eslint-webpack-plugin 替代旧版 eslint-loader，两者差异在于，
eslint-webpack-plugin 在模块构建完毕（compilation.hooks.succeedModule 钩子）后执行检查，不会阻断文件加载流程，性能更优，用法：
```shell
yarn add -D eslint-webpack-plugin
```
```javascript
const ESLintPlugin = reequire('eslint-wepback-plugin');
module.exports = {
  plugins: [new ESLintPlugin(options)]
}
```
或者，可以选择在特定条件、场景下执行 ESLint，减少对构建流程的影响，如：
- 使用编辑器插件完成 ESLint 检查、错误提示、自动 Fix，如 VS Code 的 dbaeumer.vscode-eslint 插件.
- 使用 husky，仅在代码提交前执行 ESLint 代码检查.
- 仅在 production 构建中使用 ESLint，能够有效提高开发阶段的构建效率。

8. 慎用source-map
Webpack 默认提供了一套同时兼容 CMD、AMD、ESM 等模块化方案的资源搜索规则 —— enhanced-resolve，它能将各种模块导入语句准确定位到模块对应的物理资源路径。例如：

- import 'lodash' 这一类引入 NPM 包的语句会被 enhanced-resolve 定位到对应包体文件路径 node_modules/lodash/index.js。
- import './a' 这类不带文件后缀名的语句，则可能被定位到 ./a.js 文件。
- import '@/a' 这类化名路径的引用，则可能被定位到 $PROJECT_ROOT/src/a.js 文件。

需要注意，这类增强资源搜索体验的特性背后涉及许多 IO 操作，本身可能引起较大的性能消耗，开发者可根据实际情况调整 resolve 配置，缩小资源搜索范围，包括：
**resolve.extensions 配置**

在 Webpack5 中，resolve.extensions 默认值为 ['.js', '.json', '.wasm'] ，
这意味着 Webpack 在针对不带后缀名的引入语句时，可能需要执行三次判断逻辑才能完成文件搜索，针对这种情况，可行的优化措施包括：
- 修改 resolve.extensions 配置项，减少匹配次数。
- 代码中尽量补齐文件后缀名。
- 设置 resolve.enforceExtension = true ，强制要求开发者提供明确的模块后缀名，不过这种做法侵入性太强，不太推荐。

**resolve.modules 配置**

类似于 Node 模块搜索逻辑，当 Webpack 遇到 import 'lodash' 这样的 npm 包导入语句时，会先尝试在当前项目 node_modules 目录搜索资源，
如果找不到，则按目录层级尝试逐级向上查找 node_modules 目录，如果依然找不到，则最终尝试在全局 node_modules 中搜索。

我们通常会尽量将 NPM 包安装在有限层级内，因此 Webpack 这一逐层查找的逻辑大多数情况下实用性并不高，
开发者可以通过修改 resolve.modules 配置项，主动关闭逐层搜索功能，例如：
```javascript
const path = require('path');

module.exports = {
  resolve: {
    modules: [path.resolve(__dirname, 'node_modules')]
  }
}
```

**resolve.mainFiles 配置**

与 resolve.extensions 类似，resolve.mainFiles 配置项用于定义文件夹默认文件名，
例如对于 import './dir' 请求，假设 resolve.mainFiles = ['index', 'home'] ，Webpack 会按依次测试 ./dir/index 与 ./dir/home 文件是否存在。

因此，实际项目中应控制 resolve.mainFiles 数组数量，减少匹配次数。

## SplitChunksPlugin
### 深入理解 Chunk
Chunk 是 Webpack 内部一个非常重要的底层设计，用于组织、管理、优化最终产物，在构建流程进入生成(Seal)阶段后：

1. Webpack 首先根据 entry 配置创建若干 Chunk 对象；
2. 遍历构建(Make)阶段找到的所有 Module 对象，同一 Entry 下的模块分配到 Entry 对应的 Chunk 中；
3. 遇到异步模块则创建新的 Chunk 对象，并将异步模块放入该 Chunk；
4. 分配完毕后，根据 SplitChunksPlugin 的启发式算法进一步对这些 Chunk 执行裁剪、拆分、合并、代码调优，最终调整成运行性能(可能)更优的形态；
5. 最后，将这些 Chunk 一个个输出成最终的产物(Asset)文件，编译工作到此结束。

Webpack 默认会将以下三种模块做分包处理：
- Initial Chunk：entry 模块及相应子模块打包成 Initial Chunk；
- Async Chunk：通过 import('./xx') 等语句导入的异步模块及相应子模块组成的 Async Chunk；
- Runtime Chunk：运行时代码抽离成 Runtime Chunk，可通过 entry.runtime 配置项实现。

但 Initial Chunk 与 Async Chunk 这种略显粗暴的规则会带来两个明显问题：
1. 模块重复打包

假如多个 Chunk 同时依赖同一个 Module，那么这个 Module 会被不受限制地重复打包进这些 Chunk。
2. 资源冗余 & 低效缓存：

Webpack 会将 Entry 模块、异步模块所有代码都打进同一个单独的包，这在小型项目通常不会有明显的性能问题，
但伴随着项目的推进，包体积逐步增长可能会导致应用的响应耗时越来越长。归根结底这种将所有资源打包成一个文件的方式存在两个弊端：
- 资源冗余：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码
- 缓存失效：将所有资源达成一个包后，所有改动 —— 即使只是修改了一个字符，客户端都需要重新下载整个代码包，缓存命中率极低

这两个问题都可以通过更科学的分包策略解决，例如：

- 将被多个 Chunk 依赖的包分离成独立 Chunk，防止资源重复；
- node_modules 中的资源通常变动较少，可以抽成一个独立的包，业务代码的频繁变动不会导致这部分第三方库资源缓存失效，被无意义地重复加载。

为此，Webpack 专门提供了 SplitChunksPlugin 插件，用于实现更灵活、可配置的分包，提升应用性能。
### 使用
[SplitChunksPlugin](https://webpack.docschina.org/plugins/split-chunks-plugin/) 是 Webpack 4 之后内置实现的最新分包方案。主要能力有：
- SplitChunksPlugin 支持根据 Module 路径、Module 被引用次数、Chunk 大小、Chunk 请求数等决定是否对 Chunk 做进一步拆解，这些决策都可以通过 optimization.splitChunks 相应配置项调整定制，基于这些能力我们可以实现：
  - 单独打包某些特定路径的内容，例如 node_modules 打包为 vendors；
  - 单独打包使用频率较高的文件；
- SplitChunksPlugin 还提供了 optimization.splitChunks.cacheGroup 概念，用于对不同特点的资源做分组处理，并为这些分组设置更有针对性的分包规则；
- SplitChunksPlugin 还内置了 default 与 defaultVendors 两个 cacheGroup，提供一些开箱即用的分包特性：
  - node_modules 资源会命中 defaultVendors 规则，并被单独打包；
  - 只有包体超过 20kb 的 Chunk 才会被单独打包；
  - 加载 Async Chunk 所需请求数不得超过 30；
  - 加载 Initial Chunk 所需请求数不得超过 30。

注：请求数不能等价 http 资源请求数。
#### 设置分包范围
首先，SplitChunksPlugin 默认情况下只对 Async Chunk 生效，我们可以通过 splitChunks.chunks 调整作用范围，该配置项支持如下值：
- 字符串 'all' ：对 Initial Chunk 与 Async Chunk 都生效，建议优先使用该值，效果最佳；
- 字符串 'initial' ：只对 Initial Chunk 生效；
- 字符串 'async' ：只对 Async Chunk 生效；
- 函数 (chunk) => boolean ：该函数返回 true 时生效；
```javascript
module.exports = {
  //  示例
  optimization: {
    splitChunks: {
      chunks: 'all',
    },
  },
}
```
#### 根据 Module 使用频率分包
SplitChunksPlugin 支持按 Module 被 Chunk 引用的次数决定是否分包，借助这种能力我们可以轻易将那些被频繁使用的模块打包成独立文件，减少代码重复。

用法很简单，只需用 splitChunks.minChunks 配置项设定最小引用次数，例如：
```javascript
module.exports = {
  //...
  optimization: {
    splitChunks: {
      // 设定引用次数超过 2 的模块才进行分包
      minChunks: 2
    },
  },
}
```
注意，这里“被 Chunk 引用次数”并不直接等价于被 import 的次数，而是取决于上游调用者是否被视作 Initial Chunk 或 Async Chunk 处理，例如：
```javascript
// common.js
export default "common chunk";

// async-module.js
import common from './common'

// entry-a.js
import common from './common'
import('./async-module')

// entry-b.js
import common from './common'
```
上例包含四个模块，形成如下模块关系图：

![img.png]('img/根据 Module 使用频率分包示例图.png')

其中，entry-a、entry-b 分别被视作 Initial Chunk 处理；async-module 被 entry-a 以异步方式引入，因此被视作 Async Chunk 处理。那么对于 common 模块来说，分别被三个不同的 Chunk 引入，此时引用次数为 3，配合下面的配置：
```javascript
// webpack.config.js
module.exports = {
  entry: {
    entry1: './src/entry-a.js',
    entry2: './src/entry-b.js'
  },
  // ...
  optimization: {
    splitChunks: {      
      minChunks: 2,
      //...
    }
  }
};
```
common 模块命中 optimization.splitChunks.minChunks = 2 规则，因此该模块可能会被单独分包，最终产物：

- entry1.js
- entry1.js
- async-module.js
- common.js

强调一下，上面说的是“可能”，minChunks 并不是唯一条件，此外还需要满足诸如 minSize、chunks 等限制条件才会真正执行分包，接着往下看。
#### 限制分包数量
为防止最终产物文件数量过多导致 HTTP 网络请求数剧增，反而降低应用性能，
Webpack 还提供了 maxInitialRequest/maxAsyncRequest 配置项，用于限制分包数量：
- maxInitialRequest：用于设置 Initial Chunk 最大并行请求数；
- maxAsyncRequests：用于设置 Async Chunk 最大并行请求数。

这里所说的“请求数”，是指加载一个 Chunk 时所需要加载的所有分包数。例如对于一个 Chunk A，如果根据分包规则(如模块引用次数、第三方包)
分离出了若干子 Chunk A[¡]，那么加载 A 时，浏览器需要同时加载所有的 A[¡]，此时并行请求数等于 ¡ 个分包加 A 主包，即 ¡+1。
> 提示：通过 emitAssets 等方式直接输出产物文件不在此范畴。

