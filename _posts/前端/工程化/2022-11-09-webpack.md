---
layout:     post
title:      webpack
subtitle:   
date:       2022-11-08
author:     sq
header-img: 
catalog: true
tags:
    - Webpack
---
# webpack

## 基本命令
```shell
#安装
npm install -D webpack webpack-cli
#打包
npx webpack
```

## Webpack打包流程
- 输入：从文件系统读入代码文件；
- 模块递归处理：调用 Loader 转译 Module 内容，并将结果转换为 AST，从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；
- 后处理：所有模块递归处理完毕后开始执行后处理，包括模块合并、注入运行时、产物优化等，最终输出 Chunk 集合；
- 输出：将 Chunk 写出到外部文件系统；

## webpack配置方式
- 单个配置对象：比较常用的一种方式，逻辑简单，适合大多数业务项目；
- 配置对象数组：每个数组项都是一个完整的配置对象，每个对象都会触发一次单独的构建，通常用于需要为同一份代码构建多种产物的场景，如 Library；
- 函数：Webpack 启动时会执行该函数获取配置，我们可以在函数中根据环境参数(如 NODE_ENV)动态调整配置对象。

### 数组方式
```javascript
// webpack.config.js
module.exports = [{
  name: 'amd',
  entry: './src/index.js',
  // 其它配置...
}, {
  entry: './src/index.js',
  // 其它配置...
}];
```
> 提示：使用配置数组时，还可以通过 --config-name 参数指定需要构建的配置对象，例如上例配置中若执行 npx webpack --config-name='amd'，则仅使用数组中 name='amd' 的项做构建。

### 函数方式
配置函数方式要求在配置文件中导出一个函数，并在函数中返回 Webpack 配置对象，或配置数组，或 Promise 对象，如：
```javascript
module.exports = function(env, argv) {
  // ...
  return {
    entry: './src/index.js',
    // 其它配置...
  }
}
```
运行时，Webpack 会传入两个环境参数对象：
- env：通过 --env 传递的命令行参数，适用于自定义参数，例如：

|命令：|env 参数值：|
|----|----|
|npx webpack --env prod|{ prod: true }|
|npx webpack --env prod --env min|{ prod: true, min: true }|
|npx webpack --env platform=app --env production|{ platform: "app", production: true }|
|npx webpack --env foo=bar=app|{foo: "bar=app"}|
|npx webpack --env app.platform="staging" --env app.name="test"|{ app: { platform: "staging", name: "test" }}|

- argv：命令行 [Flags](https://webpack.js.org/api/cli/#flags) 参数，支持 entry/output-path/mode/merge 等。

### 环境治理策略
通常需要将同一个应用项目部署在不同环境，对同一份代码执行各有侧重的打包策略。

除了上述配置函数方式，还可以通过将不同环境配置分别维护在单独的配置文件中。如：
```
- config
  - config.common.js 通用配置，webpack-merge合并
  - comfig.development.js 
```

之后配合 `--config` 选项指定配置目标，如：
```shell
npx webpack --config webpack.development.js
npx webpack --config=webpack.development.js
```

再配合 webpack-merge 合并配置对象，如：
```javascript
// webpack.development.js
const { merge } = require("webpack-merge");
const baseConfig = require("./webpack.common");

module.exports = merge(baseConfig, {
  mode: "development",
  devtool: "source-map",
  devServer: { hot: true }
});
```

## webpack 核心配置
### entry
entry 配置规则比较复杂，支持如下形态：
- 字符串：指定入口文件路径；
- 对象：对象形态功能比较完备，除了可以指定入口文件列表外，还可以指定入口依赖、Runtime 打包方式等；
- 函数：动态生成 Entry 配置信息，函数中可返回字符串、对象或数组；
- 数组：指明多个入口文件，数组项可以为上述介绍的文件路径字符串、对象、函数形式，Webpack 会将数组指明的入口全部打包成一个 Bundle。

这其中，对象 形态的配置逻辑最为复杂，支持如下配置属性：
- import：声明入口文件，支持路径字符串或路径数组(多入口)；
- dependOn：声明该入口的前置依赖 Bundle；
- runtime：设置该入口的 Runtime Chunk，若该属性不为空，Webpack 会将该入口的运行时代码抽离成单独的 Bundle；
- filename：效果与 output.filename 类同，用于声明该模块构建产物路径；
- library：声明该入口的 output.library 配置，一般在构建 NPM Library 时使用；
- publicPath：效果与 output.publicPath 相同，用于声明该入口文件的发布 URL；
- chunkLoading：效果与 output.chunkLoading 相同，用于声明 webpack 加载异步模块的技术方案，支持 false/jsonp/require/import 等值；
- asyncChunks：效果与 output.asyncChunks 相同，用于声明是否支持异步模块加载，默认值为 true。

#### dependOn
使用 entry.dependOn 声明入口依赖。

dependOn 属性用于声明前置 Bundle 依赖，从效果上看能够减少重复代码，优化构建产物质量。例如：
```javascript
module.exports = {
  // ...
  entry: {
    main: "./src/index.js",
    foo: { import: "./src/foo.js", dependOn: "main" },
  },
};
```

在本例中，webpack会认为加载 `foo` 前必然加载 `main`，所以会将重复的模块代码和运行时代码等都放在 `main` 中，因此 `foo` 打包产物体积会减少。

#### runtime
使用 entry.runtime 管理运行时代码。

为支持产物代码在各种环境中正常运行，Webpack 会在产物文件中注入一系列运行时代码，用以支撑起整个应用框架。运行时代码的多寡取决于我们用到多少特性，例如：

需要导入导出文件时，将注入 `__webpack_require__.r` 等；使用异步加载时，将注入 `__webpack_require__.l` 等等其他代码。

不要小看运行时代码量，极端情况下甚至有可能超过业务代码总量！为此，必要时我们可以尝试使用 runtime 配置将运行时抽离为独立 Bundle，例如：
```javascript
const path = require('path');

module.exports = {
  mode: 'development',
  devtool: false,
  entry: {
    main: {
      import: './src/index.js',
      runtime: 'common-runtime'
    },
    foo: {
      import: './src/foo.js',
      runtime: 'common-runtime'
    }
  },
  output: {
    clean: true,
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist')
  }
}
```

示例中，main 与 foo 入口均将 runtime 声明为 common-runtime，此时 Webpack 会将这两个入口的运行时代码都抽取出来，放在 common-runtime Bundle 中。

entry.runtime 是一种常用的应用性能优化手段。

### output
output 支持许多子配置项，列出部分包括：
- output.path：声明产物放在什么文件目录下；
- output.filename：声明产物文件名规则，支持 `[name]/[hash]` 等占位符；
- output.publicPath：文件发布路径，在 Web 应用中使用率较高；
- output.clean：是否自动清除 path 目录下的内容，调试时特别好用；
- output.library：NPM Library 形态下的一些产物特性，例如：Library 名称、模块化(UMD/CMD 等)规范；
- output.chunkLoading：声明加载异步模块的技术方案，支持 false/jsonp/require 等方式。

### target
Webpack 被用于打包 Web、Node、Electron等不同应用是通过 target 配置控制。支持如下配置：
- `node[[X].Y]`：编译为 Node 应用，此时将使用 Node 的 require 方法加载其它 Chunk，支持指定 Node 版本，如：node12.13；
- `async-node[[X].Y]`：编译为 Node 应用，与 node 相比主要差异在于：async-node 方式将以异步(Promise)方式加载异步模块(node 时直接使用 require)。支持指定 Node 版本，如：async-node12.13；
- `nwjs[[X].Y]`：编译为 NW.js 应用；
- `node-webkit[[X].Y]`：同 nwjs；
- `electron[[X].Y]-main`：构建为 Electron 主进程；
- `electron[[X].Y]-renderer`：构建为 Electron 渲染进程；
- `electron[[X].Y]-preload`：构建为 Electron Preload 脚本；
- web：构建为 Web 应用；
- esX：构建为特定版本 ECMAScript 兼容的代码，支持 es5、es2020 等；TODO 使用这个配置，一直打包不成功，入口文件只有一个自执行普通函数。
- browserslist：Infer a platform and the ES-features from a browserslist-config. (default if browserslist config is available)

不同构建目标会根据平台特性打包出略有差异的结果(主要体现在运行时与 NPM Library)，例如对于下面这种使用了异步导入的代码：
```javascript
// foo.js
export default "foo";

// index.js 
import("./foo").then(console.log);
```

使用如下配置，同时构建 node 与 web 版本：
```javascript
const path = require("path");
const { merge } = require("webpack-merge");

const baseConfig = {
  mode: "development",
  target: "web",
  devtool: false,
  entry: {
    main: { import: "./src/index.js" },
  },
  output: {
    clean: true,
    path: path.resolve(__dirname, "dist"),
  },
};

module.exports = [
  merge(baseConfig, { target: "web", output: { filename: "web-[name].js" } }),
  merge(baseConfig, { target: "node", output: { filename: "node-[name].js" } }),
];
```

对比构建后的产物会发现，web 版本中需要注入使用 JSONP 异步加载 JS 文件的运行时代码；而 node 版本则可以直接使用 Node 环境下的 require 实现异步加载，
因此不需要注入相关运行时。

### mode
Webpack 内置 了许多构建优化策略，我们可以通过 mode 配置项切换默认优化规则，支持如下值：

- production：默认值，生产模式，使用该值时 Webpack 会自动帮我们开启一系列优化措施：Three-Shaking、Terser 压缩代码、SplitChunk 提起公共代码，通常用于生产环境构建；
- development：开发模式，使用该值时 Webpack 会保留更语义化的 Module 与 Chunk 名称，更有助于调试，通常用于开发环境构建；
- none：关闭所有内置优化规则。

mode 规则比较简单，一般在开发模式使用 mode = 'development'，生产模式使用 mode = 'production' 即可。

## babel
Webpack 场景下，只需使用 babel-loader 即可接入 Babel 转译功能。将高版本语法转换为兼容性更强的低版本语法或 polyfill。

Preset 是 Babel 的主要应用方式之一，不同应用场景有不同 Preset 资源。

### 安装
```
npm i -D @babel/core @babel/preset-env babel-loader
```
@babel/preset-env 是一种 Babel 预设规则集，内置了一系列polyfill、插件等。可以转换 es6 到 es5。

@babel/core是babel转码的核心依赖。

### 配置方式
可以使用 `.babelrc` 文件或 `rule.options` 属性配置 Babel 功能逻辑，例如：
```javascript
module.exports = {
  /* ... */
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'babel-loader',
            // 这个部分可以被.babelrc替代
            options: {
              presets: ['@babel/preset-env']
            }
          }
        ]
      }
    ]
  }
};
```

.babelrc
```json
{
  "presets": ["@babel/preset-env"]
}
```

## typescript
Webpack 有很多种接入 TypeScript 的方法，包括 ts-loader、awesome-ts-loader、 babel-loader+@babel/preset-typescript。

### 引入ts-loader
通常可使用 ts-loader 构建 TypeScript 代码。ts-loader 会将 ts 转换为 es6 的js。
```shell
npm i -D typescript ts-loader
```

```javascript
const path = require('path');

module.exports = {
  /* xxx */
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: 'ts-loader'
      },
    ],
  },
  resolve: {
    extensions: ['.ts', '.js'],
  }
};
```

```java
//tsconfig.json
{
  "compilerOptions": {
    "noImplicitAny": true,
    "moduleResolution": "node"
  }
}
```

### 和babel-loader搭配使用
如果项目中已经使用 babel-loader，你也可以选择使用 @babel/preset-typescript 规则集，借助 babel-loader 完成 JavaScript 与 TypeScript 的转码工作。

```shell
npm i -D @babel/preset-typescript
```

```javascript
module.exports = {
  /* ... */
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'babel-loader',
            options: {
              presets: ['@babel/preset-typescript']
            }
          }
        ]
      }
    ]
  }
};
```

注意：

@babel/preset-typescript 只是简单完成代码转换，并未做类似 ts-loader 的类型检查工作。

此外它完成的是将 ts 转换为 es6 的工作，如果要转换到 es5，需要和 @babel/preset-env 搭配使用。

## eslint
在 Webpack 中，可以使用 eslint-webpack-plugin 接入 ESLint 工具

```shell
npm install -D webpack webpack-cli

npm install --save-dev eslint eslint-webpack-plugin eslint-config-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-n
```

.eslintrc文件配置
```json
{
  "extends": "standard"
}
```

webpack配置
```javascript
const ESLintPlugin = require('eslint-webpack-plugin')
module.exports = {
  plugins: [new ESLintPlugin()]
}
```

## eslint+typescript+babel
```shell
npm i -D webpack webpack-cli \
    # babel 依赖，不需要在命令行使用babel的话可以不安装@babel/cli
    @babel/core @babel/cli babel-loader \
    # TypeScript 依赖
    typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin \
    @babel/preset-typescript \
    # ESLint 依赖
    eslint eslint-webpack-plugin
```

.eslintrc配置
```json
{
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "extends": ["plugin:@typescript-eslint/recommended"]
}
```

webpack配置
```javascript
const path = require('path')
const ESLintPlugin = require('eslint-webpack-plugin')

module.exports = {
  entry: './src/index.ts',
  mode: 'development',
  devtool: false,
  output: {
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: {
          loader: 'babel-loader',
          options: { presets: ['@babel/preset-typescript'] }
        }
      }
    ]
  },
  plugins: [new ESLintPlugin({ extensions: ['.js', '.ts'] })]
}
```

## 处理样式
webpack 无法处理 css 样式，需要其他loader或plugin来处理。

常用loader或plugin：
- css-loader：该 Loader 会将 CSS 等价翻译为形如 module.exports = "${css}" 的JavaScript 代码，使得 Webpack 能够如同处理 JS 代码一样解析 CSS 内容与资源依赖；
- style-loader：该 Loader 将在产物中注入一系列 runtime 代码，这些代码会将 CSS 内容注入到页面的 style 标签，使得样式生效；
- mini-css-extract-plugin：该插件会将 CSS 代码抽离到单独的 .css 文件，并将文件通过 <link> 标签方式插入到页面中。

> 当 Webpack 版本低于 5.0 时，请使用 extract-text-webpack-plugin 代替 mini-css-extract-plugin。

### css-loader+style-loader
```
yarn add -D style-loader css-loader
```

```
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/i,
        // 保持 style-loader 在前，css-loader 在后
        use: ["style-loader", "css-loader"],
      }
    ]
  }
};
```

问题：
- JS、CSS 资源无法并行加载，从而降低页面性能；
- 资源缓存粒度变大，JS、CSS 任意一种变更都会致使缓存失效。

因此生产环境中通常会用 mini-css-extract-plugin 插件替代 style-loader，将样式代码抽离成单独的 CSS 文件。

### css-loader + mini-css-extract-plugin
mini-css-extract-plugin需要和 html-webpack-plugin 搭配使用，才能将产物以 link 标签形式插入 html。

mini-css-extract-plugin库同时提供 Loader、Plugin 组件，需要同时使用。

mini-css-extract-plugin 不能与 style-loader 混用

```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const HTMLWebpackPlugin = require('html-webpack-plugin')

module.exports = {
    module: {
        rules: [{
            test: /\.css$/,
            use: [
                (process.env.NODE_ENV === 'development' ?
                    'style-loader' :
                    MiniCssExtractPlugin.loader),
                'css-loader'
            ]
        }]
    },
    plugins: [
        new MiniCssExtractPlugin(),
        new HTMLWebpackPlugin()
    ]
}
```
### 预处理器
在rules的use数组里的css-loader后加上对应预处理器的loader（Less、Sass、Stylus）。

```javascript
module.exports = {
    module: {
        rules: [{
            use: [
                'css-loader', 
              // 预处理器loader
            ]
        }]
    }
}
```

#### postcss
postcss的使用除了postcss postcss-loader的安装外，还需要对应postcss的插件。例如我们可以使用 autoprefixer 插件自动添加浏览器前缀、[postcss-preset-env](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjonathantneal%2Fpostcss-preset-env)转译为兼容性更好的代码。

```
yarn add -D postcss postcss-loader autoprefixer
```

```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          "style-loader", 
          {
            loader: "css-loader",            
            options: {
              importLoaders: 1
            }
          }, 
          {
            loader: "postcss-loader",
            options: {
              postcssOptions: {
                // 添加 autoprefixer 插件
                plugins: [require("autoprefixer")],
              }
            }
          }
        ]
      }
    ]
  }
};
```

此外，还可以选择将 PostCSS 相关配置抽离保存到 postcss.config.js 文件：
```
module.exports = {
  plugins: [
    require("autoprefixer")
  ]
};
```

```
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // ... 忽略前面的其他loader
          'postcss-loader'
        ]
      }
    ]
  }
};
```

## vue项目环境搭建
```shell
yarn add -D webpack webpack-cli vue-loader
```
### 安装vue
```shell
#两个版本要一致
npm i vue
npm i -D vue-template-compiler
```
### vue-loader处理sfc
vue-loader 库同时提供用于处理 SFC 代码转译的 Loader 组件，与用于处理上下文兼容性的 Plugin 组件，两者需要同时配置才能正常运行。
> vue-loader高版本不处理vue2，需要15版本，如15.8.3，15.10.0

```javascript
const { VueLoaderPlugin } = require("vue-loader");

module.exports = {
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: ["vue-loader"],
      },
    ],
  },
  plugins: [new VueLoaderPlugin()],
};
```

但是sfc里面的style还是需要style-loader和css-loader处理。vue-loader依赖了 vue-style-loader，功能和 style-loader 类似，不需要再声明这个依赖，直接使用 vue-style-loader。
```javascript
module.exports = {
  rules: [
    // ...
    {
      test: /\.css$/,
      use: ["style-loader", "css-loader"],
    }
  ]
}
```
### HtmlWebpackPlugin生成入口HTML
```shell
yarn add -D html-webpack-plugin
```
```javascript
module.exports = {
  plugins: [
    // ...
    new HtmlWebpackPlugin({
      templateContent: `
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Webpack App</title>
  </head>
  <body>
    <div id="app" />
  </body>
</html>
    `,
    })
  ]
}
```
### webpack-dev-server启动本地开发服务
```shell
npm install -D webpack-dev-server
```
```javascript
module.exports = {
  devServer: {
    hot: true,
    open: true
  }
}
```
```shell
#启动服务
npx webpack serve
```
### sfc加入typescript
```shell
npm install -D typescript ts-loader
```
```javascript
module.exports = {
  rules: [
    // ...
    { test: /\.ts$/, use: ["ts-loader"] }
  ]
}
```
sfc的script标签设置lang = "typescript"。

vue-loader 会根据 lang 属性值，按 Webpack 配置的 TypeScript 规则，调用 ts-loader 处理这部分代码。支持tsconfig.json
> 同理，与处理普通 .ts、.js 文件类似的，我们还可以通过 Webpack 的 module.rule 配置项继续接入 ESLint、Babel、Flow 等工具，这些规则也都会对 Vue SFC 文件模块生效。

### sfc template处理
template的处理规则会稍微不同，因为绝大部分 Webpack 模板类 Loader 都会返回一个模板函数，而不是编译好的 HTML 片段，这与 Vue SFC 将template编译为 render 函数的规则相冲突，此时通常需要使用一个返回原始的 HTML 字符串的 loader，例如使用 pug-plain-loader，而不是 pug-loader。
```shell
yarn add -D pug pug-plain-loader
```
```javascript
module.exports = {
  rules: [
    // ...
    { test: /\.pug$/, use: ["pug-plain-loader"] },
  ]
}
```
设置 template 标签的 lang = " pug"。

### 使用 Server Side Render
SPA 引入了新的问题：SEO 不友好和Time-To-Content 更长。SSR(Server Side Render) 正是为了解决这些问题而出现的技术。

接下来，我们使用 Webpack、Vue3、Express、@vue/server-renderer 框架搭建一套完备的 Vue SSR 引用，代码地址。

1. 需要为客户端、服务端环境分别准备项目 Entry 文件。
2. 调用适当命令即可分别生成客户端、服务端版本代码：
```shell
# 客户端版本：
npx webpack --config ./webpack.client.js
# 服务端版本：
npx webpack --config ./webpack.server.js 
```
3. 编写 Node 应用代码 server.js

## webpack 构建 npm library

```
const path = require("path");

module.exports = {
  mode: "development",
  entry: "./src/index.js",
  output: {
    filename: "[name].js",
    path: path.join(__dirname, "./dist"),
    library: {
      name: '_', // 库使用时的名称
      type: 'umd' // 一般选择 umd，更通用
    }
  }
};
```

### externals peerDependencies
将第三方依赖排除在打包系统之外，避免出现使用者在业务项目中已经安装并使用了该第三方依赖，那么最终产物必然会包含两份第三方依赖代码。

例如排除lodash：
```javascript
module.exports = {
  // ...
+  externals: {
+   lodash: {
+     commonjs: "lodash",
+     commonjs2: "lodash",
+     amd: "lodash",
+     root: "_",
+   },
+ },
  // ...
};
```

再将 lodash 设置为 peerDependencies：
```
{
  "name": "",
  // ...
+ "peerDependencies": {
+   "lodash": "^4.17.21"
+ }
}
```

Webpack 编译过程会跳过 externals 所声明的库，并假定消费场景已经安装了相关依赖。

[webpack-node-externals](https://www.npmjs.com/package/webpack-node-externals) 可以排除所有 node_modules 模块，使用方法：
```javascript
// webpack.config.js
const nodeExternals = require('webpack-node-externals');

module.exports = {
  // ...
  externals: [nodeExternals()]
  // ...
};
```

### 抽离 CSS 代码
需要使用 mini-css-extract-plugin 插件将样式抽离成单独文件，方便用户使用

在前文配置基础上增加：
```
module.exports = {  
  // ...
+ module: {
+   rules: [
+     {
+       test: /\.css$/,
+       use: [MiniCssExtractPlugin.loader, "css-loader"],
+     },
+   ],
+ },
+ plugins: [new MiniCssExtractPlugin()],
};
```

### 生成 Sourcemap
NPM 库通常还需要提供 Sourcemap 文件。

设置 `devtool: 'source-map'`

此后，业务方只需使用 source-map-loader 就可以将这段 Sourcemap 信息加载到自己的业务系统中，实现框架级别的源码调试能力。

### 配置技巧
还有一些配置技巧值得注意：
- 使用 .npmignore 文件忽略不需要发布到 NPM 的文件；
- 在 package.json 文件中，使用 prepublishOnly 指令，在发布前自动执行编译命令，例如：

```json
{
  "scripts": {
    "prepublishOnly": "webpack --mode=production"
  }
}
```

- 在 package.json 文件中，使用 main 指定项目入口，同时使用 module 指定 ES Module 模式下的入口，以允许用户直接使用源码版本，例如：
```
{
  "name": "6-1_test-lib",
  // ...
  "main": "dist/main.js",
  "module": "src/index.js",
  "scripts": {
    "prepublishOnly": "webpack --mode=production"
  },
  // ...
}
```

## 如何搭建 React 全栈开发环境？

## 使用 Webpack 构建微前端应用
借助 Webpack Module Federation 实现微前端架构。

Module Federation 的基本逻辑是一端导出模块，另一端导入、使用模块，实现上两端都依赖于 Webpack 5 内置的 ModuleFederationPlugin 插件：
* 对于模块生成方，需要使用 ModuleFederationPlugin 插件的 expose 参数声明需要导出的模块列表；
* 对于模块使用方，需要使用 ModuleFederationPlugin 插件的 remotes 参数声明需要从哪些地方导入远程模块。

使用 ModuleFederationPlugin 插件后，Webpack 会将 exposes 声明的模块分别编译为独立产物，并将产物清单、MF 运行时等代码打包进 filename 定
义的应用入口文件(Remote Entry File)中。

### 简单示例

模块导出方：
```javascript
const path = require("path");
const { ModuleFederationPlugin } = require("webpack").container;

module.exports = {
  mode: "development",
  devtool: false,
  entry: path.resolve(__dirname, "./src/main.js"),
  output: {
    path: path.resolve(__dirname, "./dist"),
    // 必须指定产物的完整路径，否则使用方无法正确加载产物资源
    publicPath: `http://localhost:8081/dist/`,
  },
  plugins: [
    new ModuleFederationPlugin({
      // MF 应用名称
      name: "app1",
      // MF 模块入口，可以理解为该应用的资源清单
      filename: `remoteEntry.js`,
      // 定义应用导出哪些模块
      exposes: {
        "./utils": "./src/utils",
        "./foo": "./src/foo",
      },
    }),
  ],
  // MF 应用资源提供方必须以 http(s) 形式提供服务
  // 所以这里需要使用 devServer 提供 http(s) server 能力
  devServer: {
    port: 8081,
    hot: true,
  },
};
```

上述配置会生成如下产物：
```
MF-basic
├─ app-1
│  ├─ dist
│  │  ├─ main.js
│  │  ├─ remoteEntry.js
│  │  ├─ src_foo_js.js
│  │  └─ src_utils_js.js
```
* main.js 为整个应用的编译结果，此处可忽略；
* src_utils_js.js 与 src_foo_js.js 分别为 exposes 声明的模块的编译产物；
* remoteEntry.js 是 ModuleFederationPlugin 插件生成的应用入口文件，包含模块清单、MF 运行时代码。

模块导入方：
```javascript
const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const { ModuleFederationPlugin } = require("webpack").container;

module.exports = {
  mode: "development",
  devtool: false,
  entry: path.resolve(__dirname, "./src/main.js"),
  output: {
    path: path.resolve(__dirname, "./dist"),
  },
  plugins: [
    // 模块使用方也依然使用 ModuleFederationPlugin 插件搭建 MF 环境
    new ModuleFederationPlugin({
      // 使用 remotes 属性声明远程模块列表
      remotes: {
        // 地址需要指向导出方生成的应用入口文件
        RemoteApp: "app1@http://localhost:8081/dist/remoteEntry.js",
      },
    }),
    new HtmlWebpackPlugin(),
  ],
  devServer: {
    port: 8082,
    hot: true,
    open: true,
  },
};
```

之后在导入方中就可以使用模块名称异步导入 app-1 暴露出来的模块，例如：
```javascript
(async () => {
  const { sayHello } = await import("RemoteApp/utils");
  sayHello();
})();
```

### 依赖共享
应用相互独立，打包各自的依赖包，一般存在通用的公共依赖。为此 ModuleFederationPlugin 提供了 shared 配置用于声明该应用可被共享的依赖模块。

例如，改造上例模块导出方，添加 shared 配置：
```javascript
module.exports = {
  // ...
  plugins: [
    new ModuleFederationPlugin({
      name: "app1",
      filename: `remoteEntry.js`,
      exposes: {
        "./utils": "./src/utils",
        "./foo": "./src/foo",
      }, 
      // 可被共享的依赖模块
+     shared: ['lodash']
    }),
  ],
  // ...
};
```

接下来，还需要修改模块导入方，添加相同的 shared 配置：
```javascript
module.exports = {
  // ...
  plugins: [
    // 模块使用方也依然使用 ModuleFederationPlugin 插件搭建 MF 环境
    new ModuleFederationPlugin({
      // 使用 remotes 属性声明远程模块列表
      remotes: {
        // 地址需要指向导出方生成的应用入口文件
        RemoteApp: "app1@http://localhost:8081/dist/remoteEntry.js",
      },
+     shared: ['lodash']
    }),
    new HtmlWebpackPlugin(),
  ],
  // ...
};
```
通过添加 `shared` 属性，最终只加载了一次 lodash 产物。

注意，这里要求两个应用使用 版本号完全相同 的依赖才能被复用。如果版本号不同还是会加载两个依赖。

我们可以通过 `shared.[lib].requiredVersion` 配置项显式声明应用需要的依赖库版本来解决这个问题：
```javascript
module.exports = {
  // ...
  plugins: [
    new ModuleFederationPlugin({
      // ...
      // 共享依赖及版本要求声明
+     shared: {
+       lodash: {
    // 支持共享版本大于等于 4.17.0 小于等于 4.18.0 的 lodash
+         requiredVersion: "^4.17.0",
+       },
+     },
    }),
  ],
  // ...
};
```

requiredVersion 支持 Semantic Versioning 2.0 标准，这意味着我们可以复用 package.json 中声明版本依赖的方法。

requiredVersion 的作用在于限制依赖版本的上下限，实用性极高。除此之外，我们还可以通过 `shared.[lib].shareScope` 属性更精细地控制依赖的共享范围，例如：

```javascript
module.exports = {
  // ...
  plugins: [
    new ModuleFederationPlugin({
      // ...
      // 共享依赖及版本要求声明
+     shared: {
+       lodash: {
+         // 任意字符串
+         shareScope: 'foo'
+       },
+     },
    }),
  ],
  // ...
};
```

在这种配置下，其它应用所共享的 lodash 库必须同样声明为 foo 空间才能复用。shareScope 在多团队协作时能够切分出多个资源共享空间，降低依赖冲突的概率。

`shared` 还提供了其他配置，如：
* singletong：强制约束多个版本之间共用同一个依赖包，如果依赖包不满足版本 requiredVersion 版本要求则报警告；
* version：声明依赖包版本，缺省默认会从包体的 package.json 的 version 字段解析；
* packageName：用于从描述文件中确定所需版本的包名称，仅当无法从请求中自动确定包名称时才需要这样做；
* eager：允许 webpack 直接打包该依赖库 —— 而不是通过异步请求获取库；
* import：声明如何导入该模块，默认为 shared 属性名，实用性不高，可忽略。


## 如何借助 Webpack 开发 PWA、Node、Electron 应用？

## 图片

## 图片加载与最佳时间
### webpack4
file-loader：将图像引用转换为 url 语句并生成相应图片文件，例如使用如下配置：
```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      use: ['file-loader']
    }],
  },
};
```
url-loader：有两种表现，对于小于阈值 limit 的图像直接转化为 base64 编码；大于阈值的图像则调用 file-loader 进行加载，例如如下配置：
```javascript
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      use: [{
        loader: 'url-loader',
        options: {
          // 单位 B
          limit: 1024
        }
      }]
    }],
  },
};
```
raw-loader：不做任何转译，只是简单将文件内容复制到产物中，适用于 SVG 场景，例如如下配置：
```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.svg$/i,
        use: ['raw-loader'],
      },
    ],
  },
};
```

### webpack5
内置了[资源模块](https://webpack.js.org/guides/asset-modules/)，不再需要安装上述loader。

### 压缩
在 Webpack 生态中有不少优秀的图像压缩组件，包括：image-webpack-loader、imagemin-webpack-plugin、image-minimizer-webpack-plugin 等，
以我的使用经验来看，image-webpack-loader 组件功能齐全且用法简单，更推荐使用。基本用法首先安装依赖：

```javascript
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(gif|png|jpe?g|svg)$/i,
      type: "asset/resource",
      use: [{
        loader: 'image-webpack-loader',
        options: {
          // jpeg 压缩配置
          mozjpeg: {
            quality: 80
          },
        }
      }]
    }],
  },
};
```
image-webpack-loader 底层依赖于 imagemin 及一系列的图像优化工具：
- mozjpeg：用于压缩 JPG(JPEG) 图片；
- optipng：用于压缩 PNG 图片；
- pngquant：同样用于压缩 PNG 图片；
- svgo：用于压缩 SVG 图片；
- gifsicle：用于压缩 Gif 图；
- webp：用于将 JPG/PNG 图压缩并转化为 WebP 图片格式。

注意：图像压缩是一种非常耗时的操作，建议只在生产环境下开启。

### 雪碧图
Webpack 中，我们可以使用 webpack-spritesmith 插件自动实现雪碧图效果。HTTP2 实现 TCP 多路复用之后，雪碧图的优化效果已经微乎其微。

### 响应式图片
为不同设备提供不同的分辨率、不同尺寸的图片，兼顾显示效果和带宽。

Webpack 中有不少能够自动生成响应式图片的组件，例如： resize-image-loader、html-loader-srcset、responsive-loader 等，以 responsive-loader 为例，首先安装依赖：
```shell
yarn add -D responsive-loader sharp
```
```javascript
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      oneOf: [{
        type: "javascript/auto",
        // 实践中我们通常没必要对项目里所有图片都施加响应式特性，因此这里使用 resourceQuery 过滤出带 size/sizes 参数的图片引用，
        resourceQuery: /sizes?/,
        use: [{
          loader: "responsive-loader",
          options: {
            adapter: require("responsive-loader/sharp"),
          },
        }],
      }, {
        type: "asset/resource",
      }],
    }],
  }
};
```

使用方法：
```javascript
// 引用图片，并设置响应式参数
import responsiveImage from './webpack.jpg?sizes[]=300,sizes[]=600,sizes[]=1024';

const Picture = function () {
  return (
          <img
                  srcSet={responsiveImage.srcSet}
                  src={responsiveImage.src}
                  sizes="(min-width: 1024px) 1024px, 100vw"
                  loading="lazy"
          />
  );
};
```

上例的引用参数 './webpack.jpg?sizes[]=300,sizes[]=600,sizes[]=1024'; 最终将生成宽度分别为 300、600、1024 三张图片，之后设置 img 标签的 srcset 属性即可实现图片响应式功能。

此外，我们还能简单地通过 size 参数精确控制不同条件下的图像尺寸：

```css
.foo {
    background: url("./webpack.jpg?size=1024");
}

@media (max-width: 480px) {
    .foo {
        background: url("./webpack.jpg?size=300");
    }
}
```

## 性能分析
```javascript
// webpack.config.js
module.exports = {
  // ...
  profile: true
}
```
--json 参数，参数值为最终生成的统计文件名，执行后会生成stats.json文件。
```shell
npx webpack --json=stats.json
```
社区提供的部分优秀分析工具：
- Webpack Analysis ：Webpack 官方提供的，功能比较全面的 stats 可视化工具。
- Statoscope：主要侧重于模块与模块、模块与 chunk、chunk 与 chunk 等，实体之间的关系分析。
- Webpack Visualizer：一个简单的模块体积分析工具，真的很简单！
- Webpack Bundle Analyzer：应该是使用率最高的性能分析工具之一，主要实现以 Tree Map 方式展示各个模块的体积占比。
- Webpack Dashboard：能够在编译过程实时展示编译进度、模块分布、产物信息等。
- Unused Webpack Plugin：能够根据 stats 数据反向查找项目中未被使用的文件。
- Speed Measure Plugin：能够统计出各个 Loader、插件的处理耗时，开发者可以根据这些数据分析出哪些类型的文件处理更耗时间。

## 持久化缓存
### webpack5
https://webpack.js.org/configuration/cache/
### webpack4
原生不支持，只能借助第三方：
- 使用 [cache-loader](https://www.npmjs.com/package/cache-loader)；
- 使用 [hard-source-webpack-plugin](https://github.com/mzgoddard/hard-source-webpack-plugin)；
- 使用 Loader（如 babel-loader、eslint-loader)）自带的缓存能力。

#### cache-loader
仅缓存了 Loader 执行结果。
```shell
yarn add -D cache
```
cache-loader必须在首位。
```javascript
module.exports = {
    // ...
    module: {
        rules: [{
            test: /\.js$/,
            use: ['cache-loader', 'babel-loader', 'eslint-loader']
        }]
    },
    // ...
};
```

#### hard-source-webpack-plugin
不仅仅缓存了 Loader 运行结果，还保存了 Webpack 构建过程中许多中间数据，包括：模块、模块关系、模块 Resolve 结果、Chunks、Assets 等，效果几乎与 Webpack5 自带的 Cache 对齐。

首次运行时，hard-source-webpack-plugin 会在缓存文件夹 node_module/.cache 写入一系列日志文件。
```shell
yarn add -D hard-source-webpack-plugin
```
```javascript
const HardSourceWebpackPlugin = require("hard-source-webpack-plugin");

module.exports = {
  // ...
  plugins: [
    new HardSourceWebpackPlugin(),
  ],
};
```

### 组件自带的缓存能力
还可以使用 Webpack 组件自带的缓存能力提升特定领域的编译性能，这一类组件有：
- babel-loader；
- eslint-loader：旧版本 ESLint Webpack 组件，官方推荐使用 eslint-webpack-plugin 代替；
- eslint-webpack-plugin；
- stylelint-webpack-plugin。

cacheDirectory = true开启。默认情况下，缓存内容会被保存到 node_modules/.cache/babel-loader 目录，你也可以通过 cacheDirectory = 'dir' 属性设置缓存路径。
```javascript
module.exports = {
    // ...
    module: {
        rules: [{
            test: /\.m?js$/,
            loader: 'babel-loader',
            options: {
                cacheDirectory: true,
            },
        }]
    },
    // ...
};
```
ESLint 与 Stylelint 也提供了相应的缓存能力，设置 cache = true 可开启。
```javascript
// webpack.config.js
module.exports = {
  plugins: [
    new ESLintPlugin({ cache: true }),
    new StylelintPlugin({ files: '**/*.css', cache: true }),
  ],
};
```

## 并行构建
### happyPack
HappyPack 能够将耗时的文件加载（Loader）操作拆散到多个子进程中并发执行，子进程执行完毕后再将结果合并回传到 Webpack 进程，从而提升构建性能。
不过，HappyPack 的用法稍微有点难以理解，需要同时：

- 使用 happypack/loader 代替原本的 Loader 序列；
- 使用 HappyPack 插件注入代理执行 Loader 序列的逻辑。

```shell
yarn add -D happypack
```
将原有 loader 配置替换为 happypack/loader，如：
```javascript
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: "happypack/loader",
        // 原始配置如：
        // use: [
        //  {
        //      loader: 'babel-loader',
        //      options: {
        //          presets: ['@babel/preset-env']
        //      }
        //  },
        //  'eslint-loader'
        // ]
      },
    ],
  },
};
```
创建 happypack 插件实例，并将原有 loader 配置迁移到插件中，完整配置：
```javascript
const HappyPack = require("happypack");

module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: "happypack/loader",
        // 原始配置如：
        // use: [
        //  {
        //      loader: 'babel-loader',
        //      options: {
        //          presets: ['@babel/preset-env']
        //      }
        //  },
        //  'eslint-loader'
        // ]
      },
    ],
  },
  plugins: [
    new HappyPack({
      // 将原本定义在 `module.rules.use` 中的 Loader 配置迁移到 HappyPack 实例中
      loaders: [
        {
          loader: "babel-loader",
          option: {
            presets: ["@babel/preset-env"],
          },
        },
        "eslint-loader",
      ],
    }),
  ],
};
```
HappyPack支持创建多个实例来加载多种类型，例如：
```javascript
const HappyPack = require('happypack');

module.exports = {
  // ...
  module: {
    rules: [{
        test: /\.js?$/,
        // 使用 `id` 参数标识该 Loader 对应的 HappyPack 插件示例
        use: 'happypack/loader?id=js'
      },
      {
        test: /\.less$/,
        use: 'happypack/loader?id=styles'
      },
    ]
  },
  plugins: [
    new HappyPack({
      // 注意这里要明确提供 id 属性
      id: 'js',
      loaders: ['babel-loader', 'eslint-loader']
    }),
    new HappyPack({
      id: 'styles',
      loaders: ['style-loader', 'css-loader', 'less-loader']
    })
  ]
};
```
上面这种多实例模式虽然能应对多种类型资源的加载需求，但默认情况下反而会带来新的性能损耗。

为此，HappyPack 提供了一套简单易用的共享进程池接口，只需要创建 HappyPack.ThreadPool 对象，并通过 size 参数限定进程总量，之后将该例配置到各个 HappyPack 插件的 threadPool 属性上即可，例如：
```js
const os = require('os')
const HappyPack = require('happypack');
const happyThreadPool = HappyPack.ThreadPool({
  // 设置进程池大小
  size: os.cpus().length - 1
});

module.exports = {
  // ...
  plugins: [
    new HappyPack({
      id: 'js',
      // 设置共享进程池
      threadPool: happyThreadPool,
      loaders: ['babel-loader', 'eslint-loader']
    }),
    new HappyPack({
      id: 'styles',
      threadPool: happyThreadPool,
      loaders: ['style-loader', 'css-loader', 'less-loader']
    })
  ]
};
```
使用 HappyPack.ThreadPool 接口后，HappyPack 会预先创建好一组工作进程，所有插件实例的资源转译任务会通过内置的 HappyThread 对象转发到空闲进程做处理，避免频繁创建、销毁进程。

核心步骤：
- happlypack/loader 接受到转译请求后，从 Webpack 配置中读取出相应 HappyPack 插件实例；
- 调用插件实例的 compile 方法，创建 HappyThread 实例（或从 HappyThreadPool 取出空闲实例）；
- HappyThread 内部调用 child_process.fork 创建子进程，并执行HappyWorkerChannel 文件；
- HappyWorkerChannel 创建 HappyWorker ，开始执行 Loader 转译逻辑；

#### 缺点
作者不再维护；HappyPack 自己实现的加载器逻辑可能有兼容性问题；其主要用于文件加载阶段，并不会影响后续的产物生成、合并、优化等功能，性能收益有限。

### Thread-loader
Thread-loader 与 HappyPack 功能类似，都是以多进程方式加载文件的 Webpack 组件，两者主要区别：
持续迭代；用法简单；
HappyPack 启动后会创建一套 Mock 上下文环境 —— 包含 emitFile 等接口，并传递给 Loader，因此对大多数 Loader 来说，运行在 HappyPack 与运行在 Webpack 原生环境相比没有太大差异；但 Thread-loader 并不具备这一特性，所以要求 Loader 内不能调用特定上下文接口，兼容性较差。
```shell
#安装
yarn add -D thread-loader
```
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        // 放在 use 数组首位，确保最先运行
        use: ["thread-loader", "babel-loader", "eslint-loader"],
      },
      // 配置对象
      {
        test: /\.js$/,
        use: [
          {
            loader: "thread-loader",
            options: {
              workers: 2,
              workerParallelJobs: 50,
              // ...
            },
          },
          "babel-loader",
          "eslint-loader",
        ],
      }
    ],
  },
};
```

启动后，Thread-loader 会在加载文件时创建新的进程，在子进程中使用 loader-runner 库运行 thread-loader 之后的 Loader 组件，执行完毕后再将结果回传到 Webpack 主进程，从而实现性能更佳的文件加载转译效果。

不过，Thread-loader 也同样面临着频繁的子进程创建、销毁所带来的性能问题，为此，Thread-loader 提供了 warmup 接口用于前置创建若干工作子进程，降低构建时延，用法：
```javascript
const threadLoader = require("thread-loader");

threadLoader.warmup(
  {
    // 可传入上述 thread-loader 参数
    workers: 2,
    workerParallelJobs: 50,
  },
  [
    // 子进程中需要预加载的 node 模块
    "babel-loader",
    "babel-preset-es2015",
    "sass-loader",
  ]
);
```
#### 缺点
- 在 Thread-loader 中运行的 Loader 不能调用 emitAsset 等接口，这会导致 style-loader 这一类加载器无法正常工作，解决方案是将这类组件放置在 thread-loader 之前，如 ['style-loader', 'thread-loader', 'css-loader']；
- Loader 中不能获取 compilation、compiler 等实例对象，也无法获取 Webpack 配置。

这会导致一些 Loader 无法与 Thread-loader 共同使用

### Parallel-Webpack
Thread-loader、HappyPack 这类组件所提供的并行能力都仅作用于文件加载过程，对后续 AST 解析、依赖收集、打包、优化代码等过程均没有影响，理论收益还是比较有限的。

```shell
yarn add -D parallel-webpack

#使用
npx parallel-webpack
```
```javascript
module.exports = [{
    entry: 'pageA.js',
    output: {
        path: './dist',
        filename: 'pageA.js'
    }
}, {
    entry: 'pageB.js',
    output: {
        path: './dist',
        filename: 'pageB.js'
    }
}];
```

Parallel-Webpack 会为配置文件中导出的每个 Webpack 配置对象启动一个独立的构建进程，从而实现并行编译的效果。底层原理很简单，基本上就是在 Webpack 上套了个壳：

- 根据传入的配置项数量，调用 worker-farm 创建复数个工作进程；
- 工作进程内调用 Webpack 执行构建；
- 工作进程执行完毕后，调用 node-ipc 向主进程发送结束信号。

这种方式在需要同时执行多份配置的编译时特别有效，但若配置文件本身只是导出了单个配置对象则意义不大。

为了更好地支持多种配置的编译，Parallel-Webpack 还提供了 createVariants 函数，用于根据给定变量组合，生成多份 Webpack 配置对象，如：
```javascript
const createVariants = require('parallel-webpack').createVariants
const webpack = require('webpack')

const baseOptions = {
  entry: './index.js'
}

// 配置变量组合
// 属性名为 webpack 配置属性；属性值为可选的变量
// 下述变量组合将最终产生 2*2*4 = 16 种形态的配置对象
const variants = {
  minified: [true, false],
  debug: [true, false],
  target: ['commonjs2', 'var', 'umd', 'amd']
}

function createConfig (options) {
  const plugins = [
    new webpack.DefinePlugin({
      DEBUG: JSON.stringify(JSON.parse(options.debug))
    })
  ]
  return {
    output: {
      path: './dist/',
      filename: 'MyLib.' +
                options.target +
                (options.minified ? '.min' : '') +
                (options.debug ? '.debug' : '') +
                '.js'
    },
    plugins: plugins
  }
}

module.exports = createVariants(baseOptions, variants, createConfig)
```

虽然，parallel-webpack 相对于 Thread-loader、HappyPack 有更高的并行度，但进程实例之间并没有做任何形式的通讯，这可能导致相同的工作在不同进程 —— 或者说不同 CPU 核上被重复执行。

例如需要对同一份代码同时打包出压缩和非压缩版本时，在 parallel-webpack 方案下，前置的资源加载、依赖解析、AST 分析等操作会被重复执行，仅仅最终阶段生成代码时有所差异。

这种技术实现，对单 entry 的项目没有任何收益，只会徒增进程创建成本；但特别适合 MPA 等多 entry 场景，或者需要同时编译出 esm、umd、amd 等多种产物形态的类库场景。

## 并行压缩
Webpack4 默认使用 [Uglify-js](https://www.npmjs.com/package/uglifyjs-webpack-plugin) 实现代码压缩，Webpack5 之后则升级为 [Terser](https://webpack.js.org/plugins/terser-webpack-plugin/) —— 一种性能与兼容性更好的 JavaScript 代码压缩混淆工具，两种组件都原生实现了多进程并行压缩能力。

以 Terser 为例，TerserWebpackPlugin 插件默认已开启并行压缩，开发者也可以通过 parallel 参数（默认值为 require('os').cpus() - 1）设置具体的并发进程数量，如：
```javascript
const TerserPlugin = require("terser-webpack-plugin");

module.exports = {
    optimization: {
        minimize: true,
        minimizer: [new TerserPlugin({
            parallel: 2 // number | boolean
        })],
    },
};
```
上述配置即可设定最大并行进程数为 2。此外，Webpack4 所使用的 uglifyjs-webpack-plugin 也提供了类似的功能，用法与 Terser 相同。

理论上，并行确实能够提升系统运行效率，但 Node 单线程架构下，所谓的并行计算都只能依托与派生子进程执行，而创建进程这个动作本身就有不小的消耗 —— 大约 600ms，对于小型项目，构建成本可能可能很低，引入多进程技术反而导致整体成本增加，因此建议大家按实际需求斟酌使用上述多进程方案。

## 构建性能优化技巧
1. 使用最新版本的webpack、使用新特性。
2. 约束 Loader 执行范围。因为 Loader 在执行内容转换的过程中可能需要比较密集的 CPU 运算。通常可以排除 node_module 文件夹。

```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /.js$/,
        exclude: /node_modules/,
        use: ['babel-loader', 'eslint-loader']
      }
    ]
  }
}
```
3. 使用module.noParse跳过提前打包处理过的文件的编译。

注意：
- 由于跳过了前置的 AST 分析动作，构建过程无法发现文件中可能存在的语法错误，需要到运行（或 Terser 做压缩）时才能发现问题，所以必须确保 noParse 的文件内容正确性。
- 由于跳过了依赖分析的过程，所以文件中，建议不要包含 import/export/require/define 等模块导入导出语句 —— 换句话说，noParse 文件不能存在对其它文件的依赖，除非运行环境支持这种模块化方案。
- 由于跳过了内容分析过程，Webpack 无法标记该文件的导出值，也就无法实现 Tree-shaking。

例如：

React@18 默认定义的导出文件是 index.js。
```json
{
  "main": "index.js"
}
```
但 node_module/react/index.js 文件包含了模块导入语句 require：
```js
if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = require('./cjs/react.development.js');
}
```
此时，真正有效的代码被包含在 react.development.js（或 react.production.min.js）中，但 Webpack 只会打包这段 index.js 内容，
也就造成了产物中实际上并没有真正包含 React。针对这个问题，我们可以先找到适用的代码文件，然后用 resolve.alias 配置项重定向到该文件：
```javascript
module.exports = {
  module: {
    noParse: /react|lodash/,
    resolve: {
      alias: {
        react: path.join(__dirname,
          process.env.NODE_ENV === 'production'
          ? './node modules/react/cjs/react.production.min.js' 
          :  './node modules/react/cjs/react.development.js'
        )
      }
    }
  }
}
```
提示：使用 externals 也能将部分依赖放到构建体系之外，实现与 noParse 类似的效果，详情可查阅官网。

4. 开发模式禁用产物优化

Webpack 提供了许多产物优化功能，例如：Tree-Shaking、SplitChunks、Minimizer 等，这些能力能够有效减少最终产物的尺寸，
提升生产环境下的运行性能，但这些优化在开发环境中意义不大，反而会增加构建器的负担(都是性能大户)。

最终，建议开发环境配置如：
```javascript
module.exports = {
  mode: 'development',
  optimization: {
    // 移除已存在在所有父级模块中的模块
    removeAvailableModules: false,
    // 移除空模块
    removeEmptyChunks: false,
    // 关闭代码分包
    splitChunks: false,
    // 关闭代码压缩
    minmize: false,
    // 关闭模块合并
    concatenateModules: false,
    // 关闭 Tree-shaking 功能
    usedExports: false
  }
}
```
5. 最小化 watch 范围
在 watch 模式下（通过 npx webpack --watch 命令启动），Webpack 会持续监听项目目录中所有代码文件，
发生变化时执行 rebuild 命令。前端项目中部分资源并不会频繁更新，例如 node_modules，所以最小化 watch 范围能提高性能。
```javascript
module.exports = {
  watchOptions: {
    ignored: /node_modules/
  }
}
```
6. 跳过 TS 类型检查
类型检查涉及 AST 解析、遍历以及其它非常消耗 CPU 的操作，会给工程化流程带来比较大的性能负担，因此我们可以选择关闭 ts-loader 的类型检查功能：
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /.ts$/,
        use: [
          {
            loader: 'ts-loader',
            options: {
              // 设置为仅编译，关闭类型检查
              transpileOnly: true
            }
          }
        ]
      }
    ]
  }
}
```
然后我们可以用过以下步骤实现类型检查：
- 可以借助编辑器的 TypeScript 插件实现代码检查
- 使用 fork-ts-checker-webpack-plugin 插件将类型检查能力剥离到 子进程 执行，例如：

```javascript
const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');

module.exports = {
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: [
          {
            loader: 'ts-loader',
            options: {
              transpileOnly: true
            }
          }
        ]
      }
    ]
  },
  plugins: [
    // 用于执行类型检查
    new ForkTsCheckerWebpackPlugin()
  ]
}
```
这样，既可以获得 Typescript 静态类型检查能力，又能提升整体编译速度。
7. 优化 ESLint 性能
使用 eslint-loader 实现实时代码检查，会带来比较高昂且不必要的性能成本，我们可以选择其它更聪明的方式接入 ESLint。

例如，使用新版本组件 eslint-webpack-plugin 替代旧版 eslint-loader，两者差异在于，
eslint-webpack-plugin 在模块构建完毕（compilation.hooks.succeedModule 钩子）后执行检查，不会阻断文件加载流程，性能更优，用法：
```shell
yarn add -D eslint-webpack-plugin
```
```javascript
const ESLintPlugin = reequire('eslint-wepback-plugin');
module.exports = {
  plugins: [new ESLintPlugin(options)]
}
```
或者，可以选择在特定条件、场景下执行 ESLint，减少对构建流程的影响，如：
- 使用编辑器插件完成 ESLint 检查、错误提示、自动 Fix，如 VS Code 的 dbaeumer.vscode-eslint 插件.
- 使用 husky，仅在代码提交前执行 ESLint 代码检查.
- 仅在 production 构建中使用 ESLint，能够有效提高开发阶段的构建效率。

8. 慎用source-map
Webpack 默认提供了一套同时兼容 CMD、AMD、ESM 等模块化方案的资源搜索规则 —— enhanced-resolve，它能将各种模块导入语句准确定位到模块对应的物理资源路径。例如：

- import 'lodash' 这一类引入 NPM 包的语句会被 enhanced-resolve 定位到对应包体文件路径 node_modules/lodash/index.js。
- import './a' 这类不带文件后缀名的语句，则可能被定位到 ./a.js 文件。
- import '@/a' 这类化名路径的引用，则可能被定位到 $PROJECT_ROOT/src/a.js 文件。

需要注意，这类增强资源搜索体验的特性背后涉及许多 IO 操作，本身可能引起较大的性能消耗，开发者可根据实际情况调整 resolve 配置，缩小资源搜索范围，包括：
**resolve.extensions 配置**

在 Webpack5 中，resolve.extensions 默认值为 ['.js', '.json', '.wasm'] ，
这意味着 Webpack 在针对不带后缀名的引入语句时，可能需要执行三次判断逻辑才能完成文件搜索，针对这种情况，可行的优化措施包括：
- 修改 resolve.extensions 配置项，减少匹配次数。
- 代码中尽量补齐文件后缀名。
- 设置 resolve.enforceExtension = true ，强制要求开发者提供明确的模块后缀名，不过这种做法侵入性太强，不太推荐。

**resolve.modules 配置**

类似于 Node 模块搜索逻辑，当 Webpack 遇到 import 'lodash' 这样的 npm 包导入语句时，会先尝试在当前项目 node_modules 目录搜索资源，
如果找不到，则按目录层级尝试逐级向上查找 node_modules 目录，如果依然找不到，则最终尝试在全局 node_modules 中搜索。

我们通常会尽量将 NPM 包安装在有限层级内，因此 Webpack 这一逐层查找的逻辑大多数情况下实用性并不高，
开发者可以通过修改 resolve.modules 配置项，主动关闭逐层搜索功能，例如：
```javascript
const path = require('path');

module.exports = {
  resolve: {
    modules: [path.resolve(__dirname, 'node_modules')]
  }
}
```

**resolve.mainFiles 配置**

与 resolve.extensions 类似，resolve.mainFiles 配置项用于定义文件夹默认文件名，
例如对于 import './dir' 请求，假设 resolve.mainFiles = ['index', 'home'] ，Webpack 会按依次测试 ./dir/index 与 ./dir/home 文件是否存在。

因此，实际项目中应控制 resolve.mainFiles 数组数量，减少匹配次数。

## SplitChunksPlugin
Webpack 默认会将尽可能多的模块代码打包在一起，优点是能减少最终页面的 HTTP 请求数，但缺点也很明显：

- 页面初始代码包过大，影响首屏渲染性能；
- 无法有效应用浏览器缓存，特别对于 NPM 包这类变动较少的代码，业务代码哪怕改了一行都会导致 NPM 包缓存失效。

SplitChunksPlugin 插件专门用于根据产物包的体积、引用次数等做分包优化，规避上述问题。

SplitChunksPlugin 的使用方法比较复杂，我们得从 Chunk 这个概念开始说起。

### 深入理解 Chunk
Chunk 是 Webpack 内部一个非常重要的底层设计，用于组织、管理、优化最终产物，在构建流程进入生成(Seal)阶段后：

1. Webpack 首先根据 entry 配置创建若干 Chunk 对象；
2. 遍历构建(Make)阶段找到的所有 Module 对象，同一 Entry 下的模块分配到 Entry 对应的 Chunk 中；
3. 遇到异步模块则创建新的 Chunk 对象，并将异步模块放入该 Chunk；
4. 分配完毕后，根据 SplitChunksPlugin 的启发式算法进一步对这些 Chunk 执行裁剪、拆分、合并、代码调优，最终调整成运行性能(可能)更优的形态；
5. 最后，将这些 Chunk 一个个输出成最终的产物(Asset)文件，编译工作到此结束。

Webpack 默认会将以下三种模块做分包处理：
- Initial Chunk：entry 模块及相应子模块打包成 Initial Chunk；
- Async Chunk：通过 import('./xx') 等语句导入的异步模块及相应子模块组成的 Async Chunk；
- Runtime Chunk：运行时代码抽离成 Runtime Chunk，可通过 entry.runtime 配置项实现。

但 Initial Chunk 与 Async Chunk 这种略显粗暴的规则会带来两个明显问题：
1. 模块重复打包

假如多个 Chunk 同时依赖同一个 Module，那么这个 Module 会被不受限制地重复打包进这些 Chunk。
2. 资源冗余 & 低效缓存：

Webpack 会将 Entry 模块、异步模块所有代码都打进同一个单独的包，这在小型项目通常不会有明显的性能问题，
但伴随着项目的推进，包体积逐步增长可能会导致应用的响应耗时越来越长。归根结底这种将所有资源打包成一个文件的方式存在两个弊端：
- 资源冗余：客户端必须等待整个应用的代码包都加载完毕才能启动运行，但可能用户当下访问的内容只需要使用其中一部分代码
- 缓存失效：将所有资源达成一个包后，所有改动 —— 即使只是修改了一个字符，客户端都需要重新下载整个代码包，缓存命中率极低

这两个问题都可以通过更科学的分包策略解决，例如：

- 将被多个 Chunk 依赖的包分离成独立 Chunk，防止资源重复；
- node_modules 中的资源通常变动较少，可以抽成一个独立的包，业务代码的频繁变动不会导致这部分第三方库资源缓存失效，被无意义地重复加载。

为此，Webpack 专门提供了 SplitChunksPlugin 插件，用于实现更灵活、可配置的分包，提升应用性能。

### 使用
[SplitChunksPlugin](https://webpack.docschina.org/plugins/split-chunks-plugin/) 是 Webpack 4 之后内置实现的最新分包方案。主要能力有：
- SplitChunksPlugin 支持根据 Module 路径、Module 被引用次数、Chunk 大小、Chunk 请求数等决定是否对 Chunk 做进一步拆解，这些决策都可以通过 optimization.splitChunks 相应配置项调整定制，基于这些能力我们可以实现：
  - 单独打包某些特定路径的内容，例如 node_modules 打包为 vendors；
  - 单独打包使用频率较高的文件；
- SplitChunksPlugin 还提供了 optimization.splitChunks.cacheGroup 概念，用于对不同特点的资源做分组处理，并为这些分组设置更有针对性的分包规则；
- SplitChunksPlugin 还内置了 default 与 defaultVendors 两个 cacheGroup，提供一些开箱即用的分包特性：
  - node_modules 资源会命中 defaultVendors 规则，并被单独打包；
  - 只有包体超过 20kb 的 Chunk 才会被单独打包；
  - 加载 Async Chunk 所需请求数不得超过 30；
  - 加载 Initial Chunk 所需请求数不得超过 30。

注：请求数不能等价 http 资源请求数。

#### 设置分包范围
首先，SplitChunksPlugin 默认情况下只对 Async Chunk 生效，我们可以通过 splitChunks.chunks 调整作用范围，该配置项支持如下值：
- 字符串 'all' ：对 Initial Chunk 与 Async Chunk 都生效，建议优先使用该值，效果最佳；
- 字符串 'initial' ：只对 Initial Chunk 生效；
- 字符串 'async' ：只对 Async Chunk 生效；
- 函数 (chunk) => boolean ：该函数返回 true 时生效；

```javascript
module.exports = {
  //  示例
  optimization: {
    splitChunks: {
      chunks: 'all',
    },
  },
}
```

#### 根据 Module 使用频率分包
SplitChunksPlugin 支持按 Module 被 Chunk 引用的次数决定是否分包，借助这种能力我们可以轻易将那些被频繁使用的模块打包成独立文件，减少代码重复。

用法很简单，只需用 splitChunks.minChunks 配置项设定最小引用次数，例如：
```javascript
module.exports = {
  //...
  optimization: {
    splitChunks: {
      // 设定引用次数超过 2 的模块才进行分包
      minChunks: 2
    },
  },
}
```
注意，这里“被 Chunk 引用次数”并不直接等价于被 import 的次数，而是取决于上游调用者是否被视作 Initial Chunk 或 Async Chunk 处理，例如：
```javascript
// common.js
export default "common chunk";

// async-module.js
import common from './common'

// entry-a.js
import common from './common'
import('./async-module')

// entry-b.js
import common from './common'
```
上例包含四个模块，形成如下模块关系图：

![img.png]('img/根据 Module 使用频率分包示例图.png')

其中，entry-a、entry-b 分别被视作 Initial Chunk 处理；async-module 被 entry-a 以异步方式引入，因此被视作 Async Chunk 处理。那么对于 common 模块来说，分别被三个不同的 Chunk 引入，此时引用次数为 3，配合下面的配置：
```javascript
// webpack.config.js
module.exports = {
  entry: {
    entry1: './src/entry-a.js',
    entry2: './src/entry-b.js'
  },
  // ...
  optimization: {
    splitChunks: {      
      minChunks: 2,
      //...
    }
  }
};
```
common 模块命中 optimization.splitChunks.minChunks = 2 规则，因此该模块可能会被单独分包，最终产物：

- entry1.js
- entry1.js
- async-module.js
- common.js

强调一下，上面说的是“可能”，minChunks 并不是唯一条件，此外还需要满足诸如 minSize、chunks 等限制条件才会真正执行分包，接着往下看。
#### 限制分包数量
为防止最终产物文件数量过多导致 HTTP 网络请求数剧增，反而降低应用性能，
Webpack 还提供了 maxInitialRequest/maxAsyncRequest 配置项，用于限制分包数量：
- maxInitialRequest：用于设置 Initial Chunk 最大并行请求数；
- maxAsyncRequests：用于设置 Async Chunk 最大并行请求数。

这里所说的“请求数”，是指加载一个 Chunk 时所需要加载的所有分包数。例如对于一个 Chunk A，如果根据分包规则(如模块引用次数、第三方包)
分离出了若干子 `Chunk A[¡]`，那么加载 A 时，浏览器需要同时加载所有的 `A[¡]`，此时并行请求数等于 ¡ 个分包加 A 主包，即 ¡+1。
> 提示：通过 emitAssets 等方式直接输出产物文件不在此范畴。

// TODO 16 

## Plugin
Plugin 具有参与webpack构建流程的能力。

一个插件的基本结构：是一个函数或类，原型上有 apply 方法，在其中监听某一个webpack派发的[事件](https://webpack.js.org/api/compiler-hooks/)，操作webpack内部实例数据或调用api。

apply方法会在webpack compiler安装插件时被调用一次，第一个参数是compiler。

插件定义后要使用，要在webpack配置文件导出的对象中配置，将插件实例添加到 `plugins` 数组中。

可以使用 schema-utils 校验插件构造函数的参数，如：

```javascript
import { validate } from 'schema-utils';

// schema for options object
const schema = {
  type: 'object',
  properties: {
    test: {
      type: 'string',
    },
  },
};

export default class HelloWorldPlugin {
  constructor(options = {}) {
    validate(schema, options, {
      name: 'Hello World Plugin',
      baseDataPath: 'options',
    });
  }

  apply(compiler) {}
}
```

## 监听event hooks
有些事件是异步的，可以用同步（tap）或异步方法（tapAsync）去监听。

### tapAsync
当使用 tapAsync 方法监听事件，需要调用作为我们函数参数的最后一个参数的回调函数。

```javascript
class HelloAsyncPlugin {
  apply(compiler) {
    compiler.hooks.emit.tapAsync(
      'HelloAsyncPlugin',
      (compilation, callback) => {
        // Do something async...
        setTimeout(function () {
          console.log('Done with async work...');
          callback();
        }, 1000);
      }
    );
  }
}

module.exports = HelloAsyncPlugin;
```

### tapPromise
当使用tapPromise，我们需要返回一个promise，在我们异步任务完成后resolve。

```javascript
class HelloAsyncPlugin {
  apply(compiler) {
    compiler.hooks.emit.tapPromise('HelloAsyncPlugin', (compilation) => {
      // return a Promise that resolves when we are done...
      return new Promise((resolve, reject) => {
        setTimeout(function () {
          console.log('Done with async work...');
          resolve();
        }, 1000);
      });
    });
  }
}

module.exports = HelloAsyncPlugin;
```

### 一个生成文件，列出本次打包所有asset的插件

```javascript
class FileListPlugin {
  static defaultOptions = {
    outputFile: 'assets.md',
  };

  // Any options should be passed in the constructor of your plugin,
  // (this is a public API of your plugin).
  constructor(options = {}) {
    // Applying user-specified options over the default options
    // and making merged options further available to the plugin methods.
    // You should probably validate all the options here as well.
    this.options = { ...FileListPlugin.defaultOptions, ...options };
  }

  apply(compiler) {
    const pluginName = FileListPlugin.name;

    // webpack module instance can be accessed from the compiler object,
    // this ensures that correct version of the module is used
    // (do not require/import the webpack or any symbols from it directly).
    const { webpack } = compiler;

    // Compilation object gives us reference to some useful constants.
    const { Compilation } = webpack;

    // RawSource is one of the "sources" classes that should be used
    // to represent asset sources in compilation.
    const { RawSource } = webpack.sources;

    // Tapping to the "thisCompilation" hook in order to further tap
    // to the compilation process on an earlier stage.
    compiler.hooks.thisCompilation.tap(pluginName, (compilation) => {
      // Tapping to the assets processing pipeline on a specific stage.
      compilation.hooks.processAssets.tap(
        {
          name: pluginName,

          // Using one of the later asset processing stages to ensure
          // that all assets were already added to the compilation by other plugins.
          stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
        },
        (assets) => {
          // "assets" is an object that contains all assets
          // in the compilation, the keys of the object are pathnames of the assets
          // and the values are file sources.

          // Iterating over all the assets and
          // generating content for our Markdown file.
          const content =
            '# In this build:\n\n' +
            Object.keys(assets)
              .map((filename) => `- ${filename}`)
              .join('\n');

          // Adding new asset to the compilation, so it would be automatically
          // generated by the webpack in the output directory.
          compilation.emitAsset(
            this.options.outputFile,
            new RawSource(content)
          );
        }
      );
    });
  }
}

module.exports = { FileListPlugin };
```

```javascript
const { FileListPlugin } = require('./file-list-plugin.js');

// Use the plugin in your webpack configuration:
module.exports = {
  // …

  plugins: [
    // Adding the plugin with the default options
    new FileListPlugin(),

    // OR:

    // You can choose to pass any supported options to it:
    new FileListPlugin({
      outputFile: 'my-assets.md',
    }),
  ],
};
```

// TODO
Tip
We are using synchronous tap() method to tap into the

https://webpack.js.org/contribute/writing-a-plugin/

## 资料
模块联邦例子 https://github.com/module-federation/module-federation-examples/

Webpack5 核心原理与应用实践 https://juejin.cn/book/7115598540721618944?enter_from=course_center&utm_source=course_center
