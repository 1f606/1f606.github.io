---
layout:     post
title:      fetch
subtitle:   
date:       2023-2-13
author:     
header-img: 
catalog: true
tags:
    - fetch
    - CORS
---
# fetch
## 初始化
```javascript
let promise = fetch(url, [options])
```
参数：
- url —— 要访问的 URL。
- options —— 可选参数：method，header 等。

浏览器会立即启动请求，并返回一个该调用代码应该用来获取结果的 promise。

## 响应
响应的属性：
- response.status —— response 的 HTTP 状态码，
- response.ok —— HTTP 状态码为 200-299，则为 true。
- response.headers —— 类似于 Map 的带有 HTTP header 的对象。

```javascript
const response = await fetch(url);
if (response.ok) {
  const json = await response.json();
}
```

获取响应通常需要经过两个阶段。

第一阶段，当服务器发送了响应头（response header），fetch 返回的 promise 就使用内建的 Response class 对象来对响应头进行解析。

第二阶段，为了获取 response body，我们需要使用一个其他的方法调用。
- response.text() —— 读取 response，并以文本形式返回 response，
- response.json() —— 将 response 解析为 JSON 格式，
- response.formData() —— 以 FormData 对象（在 下一章 有解释）的形式返回 response，
- response.blob() —— 以 Blob（具有类型的二进制数据）形式返回 response，
- response.arrayBuffer() —— 以 ArrayBuffer（低级别的二进制数据）形式返回 response，

另外，response.body 是 ReadableStream 对象，它允许你逐块读取 body，我们稍后会用一个例子解释它。

> 重要：
> 
> 我们只能选择一种读取 body 的方法。如果我们已经使用了 response.text() 方法来获取 response，那么如果再用 response.json()，则不会生效，因为 body 内容已经被处理过了。

### Response header
Response header 位于 response.headers 中的一个类似于 Map 的 header 对象。

它不是真正的 Map，但是它具有类似的方法，我们可以按名称（name）获取各个 header，或迭代它们：
```javascript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

// 获取一个 header
alert(response.headers.get('Content-Type')); // application/json; charset=utf-8

// 迭代所有 header
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`);
}
```

### Request header
要在 fetch 中设置 request header，我们可以使用 headers 选项。它有一个带有输出 header 的对象，如下所示：
```javascript
let response = fetch(protectedUrl, {
  headers: {
    Authentication: 'secret'
  }
});
```

但是有一些是我们无法设置的header，仅由浏览器控制。https://fetch.spec.whatwg.org/#forbidden-header-name

## post 请求
要创建一个 POST 请求，或者其他方法的请求，我们需要使用 fetch 选项：
- method —— HTTP 方法，例如 POST，
- body —— request body，其中之一：字符串（例如 JSON 编码的），
  - FormData 对象，以 multipart/form-data 形式发送数据，
  - Blob/BufferSource 发送二进制数据，
  - URLSearchParams，以 x-www-form-urlencoded 编码形式发送数据，很少使用。

请注意，如果请求的 body 是字符串，则 Content-Type 会默认设置为 text/plain;charset=UTF-8。

## 发送图片
我们同样可以使用 Blob 或 BufferSource 对象通过 fetch 提交二进制数据。
```html
<body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="Submit" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
      let response = await fetch('/article/fetch/post/image', {
        method: 'POST',
        body: blob
      });

      // 服务器给出确认信息和图片大小作为响应
      let result = await response.json();
      alert(result.message);
    }

  </script>
</body>
```
这里我们没有手动设置 Content-Type header，因为 Blob 对象具有内建的类型（这里是 image/png，通过 toBlob 生成的）。
对于 Blob 对象，这个类型就变成了 Content-Type 的值。

## 跟踪下载进度
fetch 方法无法跟踪 上传 进度。只能通过 XMLHttpRequest。

To track download process, we can use `response.body` property. It's a ReadableStream.

Unlike `response.text()`, `response.json()` and other methods, we can count how much is consumed at any moment using `response.body`.

Here's the sketch of code.
```javascript
const reader = response.body.getReader();

// infinite loop while the body is downloading
while (true) {
  // down is true for the last chunk
  // value is Uint8Array of the chunk bytes
  const {done, value} = await reader.read();
  
  if (done) {
    break;
  }
}

console.log(`Received ${value.length} bytes`);
```

> Please note. Streams API describes asynchronous iteration over ReadableStream with for await..of loop, but it's not yet widely supported.

Here's a full working example.
```javascript
// start the fetch and obtain a reader
const response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');

const reader = response.body.getReader();

// prior to reading, we can figure out the full response length from the Content-Length header.
// if the size is unknown, we should check receivedLength in the loop and break it once it reaches a certain limit. So that the chunks won’t overflow the memory.
const contentLength = +response.headers.get('Content-Length');

// read the data
let receivedLength = 0;
// We gather response chunks in the array chunks. because after the response is consumed, we won’t be able to “re-read” it
const chunks = [];
while (true) {
  const {done, value} = await reader.read();
  
  if (done) {
    break;
  }
  
  chunks.push(value);
  receivedLength += value.length;
}

// concatenate chunks into single Uint8Array
const chunksAll = new Uint8Array(receivedLength);
let position = 0;
for (const chunk of chunks) {
  chunksAll.set(chunk, position);
  position += chunk.length;
}

// if we need binary content instead of a string. creates a Blob from all chunks:
let blob = new Blob(chunks);

// decode into a string
const result = new TextDecoder('utf-8').decode(chunksAll);

const commits = JSON.parse(result);
console.log(commits[0].author.login);
```

## 跨域请求
有两种类型的跨源请求：
- 安全请求。
- 所有其他请求。

### 安全请求
如果一个请求满足下面这两个条件，则该请求是安全的：
- GET, POST 或 HEAD
- 仅允许自定义下列 header。
  - Accept
  - Accept-Language
  - Content-Language
  - Content-Type 的值为 application/x-www-form-urlencoded，multipart/form-data 或 text/plain。

可以使用 `<form>` 或 `<script>` 进行安全请求。

### 非安全请求
浏览器发送非安全请求前，会先发送预检（preflight）请求。预检请求对JS不可见。

预检请求使用 OPTIONS 方法，它没有 body，但是有三个 header：
- Access-Control-Request-Method header 带有非安全请求的方法。
- Access-Control-Request-Headers header 提供一个以逗号分隔的非安全 HTTP-header 列表。
- origin

如果服务器同意处理请求，那么它会进行响应，此响应的状态码应该为 200，没有 body，具有 header：
- Access-Control-Allow-Origin 必须为 * 或进行请求的源（例如 https://javascript.info）才能允许此请求。
- Access-Control-Allow-Methods 必须具有允许的方法。
- Access-Control-Allow-Headers 必须具有一个允许的 header 列表。

另外，header Access-Control-Max-Age 可以指定缓存此权限的秒数，在缓存时间内无需再次发送预检请求。

然后浏览器会发起实际请求，响应需要带有Access-Control-Allow-Origin。

### 响应头
对于跨源请求，默认情况下，JavaScript 只能访问“安全的” response header：
- Cache-Control
- Content-Language
- Content-Type
- Expires
- Last-Modified
- Pragma

访问任何其他 response header 都将导致 error。

要授予 JavaScript 对任何其他 response header 的访问权限，服务器必须发送 Access-Control-Expose-Headers 响应头。
它包含一个以逗号分隔的应该被设置为可访问的非安全 header 名称列表。

### 凭证
默认情况下，由 JavaScript 代码发起的跨源请求不会带来任何凭据（cookies 或者 HTTP 认证（HTTP authentication））。即使是同源的cookie。

要在 fetch 中发送凭据，我们需要添加 credentials: "include" 选项，像这样：
```javascript
fetch('http://localhost', {
  credentials: 'include'
});
```
这时请求会携带同源的cookie。

如果服务器同意接受 带有凭据 的请求，服务器还应该在响应中额外添加 header Access-Control-Allow-Credentials: true。

请注意：对于具有凭据的请求，禁止 Access-Control-Allow-Origin 使用星号 *。它必须有一个确切的源。这是另一项安全措施，以确保服务器真的知道它信任的发出此请求的是谁。

### 请求过程
1. 对于非安全请求，浏览器发出带有三个 header 的预检请求。
2. 服务器端响应200，并有三个 header（Max-Age可选）。
3. 发送带有 origin header 的请求。
4. 服务器响应带有 Access-Control-Allow-Origin，对于有凭证的请求，Access-Control-Allow-Credentials 为 true，
Allow-Origin 应与 origin 相同（出于安全）。要允许 JS 访问除默认列表外的 header，服务器应该在 header Access-Control-Expose-Headers 中列出那些 header。

### Referer 和 Origin
Referer 可能不会被发送，甚至允许被修改。Origin能保证正确。

## 任务
https://zh.javascript.info/fetch#cong-githubfetch-yong-hu-xin-xi