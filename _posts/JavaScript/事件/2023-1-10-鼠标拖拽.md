---
layout:     post
title:      鼠标拖拽
subtitle:   
date:       2023-1-10
author:     
header-img: 
catalog: true
tags:
    - JavaScript
    - 事件
---
# 鼠标拖拽
## 基础
基础的拖放算法如下所示：
1. 在 mousedown 上 —— 根据需要初始化相关变量等。
2. 然后在 mousemove 上，通过更改 left/top 来移动它。
3. 在 mouseup 上 —— 执行与完成拖放相关的所有行为。

注意：
被拖动元素的 dragstart 和 mousedown 事件需要禁止浏览器的默认行为，否则拖动时会出现不符合预期的行为。

禁止选中也可以通过设置 css 样式
```css
body {
    user-select: none;
}
iframe {
    pointer-events: none;
}
```

例子：
```javascript
elem.onmousedown = function (event) {
  const shiftX = event.clientX - elem.getBoundingClientRect().left;
  const shiftY = event.clientY - elem.getBoundingClientRect().top;
  
  elem.style.position = 'absolute';
  elem.style.zIndex = 1000;
  document.body.append(ball);
  
  moveAt(event.pageX, event.pageY);
  
  function moveAt (pageX, pageY) {
    elem.style.left = pageX - shiftX + 'px';
    elem.style.top = pageY - shiftY + 'px';
  }
  
  function onMouseMove (event) {
    moveAt(event.pageX, event.pageY);
  }
  
  document.addEventListener('mousemove', onMouseMove);
  
  elem.onmouseup = function () {
    document.removeEventListener('mousemove', onMouseMove);
    elem.onmouseup = null;
  }
};

elem.ondragestart = function () {
  return false;
};
```
## 鼠标事件中拿到当前顶层元素
鼠标事件只发生在最顶层元素上，被遮挡的元素无法触发，那么在 mousemove 事件中，我们无法判断是否拖动到了可拖放区域。

解决方法时可以先将当前拖拽元素隐藏，然后调用 document.elementFromPoint(clientX, clientY)，拿到最上层元素后，再显示当前拖拽元素。

因此我们修改 onMouseMove 方法：
```javascript
let currentDroppable = null;
function onMouseMove (event) {
  moveAt(event.pageX, event.pageY);
  
  elem.hidden = true;
  const elemBelow = document.elementFromPoint(event.clientX, event.clientY);
  elem.hidden = false;
  
  if (!elemBelow) return;
  
  const droppableBelow = elemBelow.closest('.droppable');
  if (currentDroppable !== droppableBelow) {
    if (currentDroppable) {
      leaveDroppable(currentDroppable);
    }
    currentDroppable = droppableBelow;
    if (currentDroppable) {
      enterDroppable(currentDroppable);
    }
  }
}
```
## drag
在 HTML 中，除了图像、链接和选择的文本默认的可拖拽行为之外，其他元素在默认情况下是不可拖拽的。图像和链接的 URL 以及文本被设置为拖拽数据。

要使其他的 HTML 元素可拖拽：
- 元素的 draggable 属性设置成 true。
- 为 dragstart 添加监听程序，在其中设置拖拽数据。

当用户开始拖拽时，会触发 dragstart 事件。dragstart 是冒泡事件。
### 拖拽数据
所有 拖拽事件 都有一个名为 dataTransfer 的属性，它持有拖拽数据。拖拽数据 包含两个信息，数据的类型（或格式）和数据值。

拖拽数据的类型属性返回一个类似 DOMString 的 MIME-type 的列表，你还可以创建自己的类型。
最常用的类型列在文章[推荐拖拽类型](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API/Recommended_drag_types)中。

#### 数据的添加和删除
要在 dataTransfer 中设置拖拽数据项，使用 setData() 方法。这个方法接收两个参数，即数据类型和数据值。例如：
`event.dataTransfer.setData("text/plain", "Text to drag");`

如果你试图以相同的格式添加两次数据，那么新的数据将替换旧的数据。

你可以使用 clearData() 方法清除这些数据，该方法接收一个参数，即要删除的数据类型。
如果没有声明 type，则所有类型的数据都会被删除。如果拖拽不包含拖拽数据项，或者所有的数据项都被清除，那么就不会出现拖拽行为。

### 设置拖拽反馈图像
当拖拽发生时，会自动生成拖拽目标的一个半透明图像（触发 dragstart 事件的元素）。你可以使用 `setDragImage()` 方法来自定义拖拽反馈图像。

`event.dataTransfer.setDragImage(image, xOffset, yOffset);`

### 拖拽效果
拖拽过程中可能会执行一些操作。可以在 dragstart 事件监听程序中设置 effectAllowed 属性以指定允许拖拽源头执行三种操作中的哪几种。属性默认允许所有的操作。

copy 操作用来指示被拖拽的数据将从当前位置复制到放置位置。 move 操作指示被拖拽的数据会被移动，link 操作表示在源和放置位置之间将会创建某种形式的关系或连接。

`event.dataTransfer.effectAllowed = "copy";`

以上代码只允许复制，在拖拽到不支持复制的容器时鼠标会显示禁止标识。

### dropEffect
在拖拽操作期间，dragenter 或 dragover 事件的监听程序可以检查 effectAllowed 属性，以查看哪些操作是允许的。
相关的 dropEffect 属性应该在其中的一个事件中设置，来指定应该执行哪一个单项操作。dropEffect 是 none, copy, move, 或 link。

DataTransfer.dropEffect 属性控制在拖放操作中给用户的反馈（通常是视觉上的）。它会影响在拖拽过程中**光标的手势**。

此外在 dragenter 和 dragover 事件中，dropEffect 属性被初始化为用户请求的效果。用户可以通过按下修饰键来修改为所需的效果。如 alt、ctrl 和 shift。
你可以在 dragenter 或 dragover 事件期间修改 dropEffect 属性，例如将某个放置目标设置为只支持某些操作，覆盖用户指定的效果。

在 drop 和 dragend 事件中，你可以检查 dropEffect 属性，以确定最终选择了哪种效果。如果所选的效果是 "move"，那么应该在 dragend 事件中从拖拽源头删除拖拽数据。

### 指定放置目标
dragenter 或 dragover 事件的监听程序用于表示有效的放置目标，也就是被拖拽项目可能放置的地方。
网页或应用程序的大多数区域都不是放置数据的有效位置，因此，这些事件的默认处理是不允许放置。

如果你想要允许放置，你必须取消 dragenter 或 dragover 事件来阻止默认的处理。

#### 放置反馈
鼠标指针将根据 dropEffect 属性展示。大多数情况下，鼠标反馈就够了。但我们还可以通过 css 更新界面。

例如-moz-drag-over CSS 伪类。在 dragenter 事件阻止默认行为，样式就会生效，尽管这个伪类叫 drag-over。

对于复杂的效果，可以在 dragenter 插入元素。dragover 事件在鼠标指向的元素上触发，可以通过事件属性将元素移动到鼠标位置。

dragleave 事件会在拖拽离开元素时在该元素上触发。即使拖拽被取消，事件也会触发，所以可以确保在该事件中的清除操作一定会完成。

### 执行放置
当用户放开鼠标，拖放操作就会结束。 如果在有效的放置目标元素（即取消了 dragenter 或 dragover 事件的元素）上放开鼠标，放置就会成功，
drop 事件就会在目标元素上触发。否则，拖拽会被取消，不会触发 drop。

在 drop 事件中，你应该取回放置的数据并将其插入到放置的位置。

在所有拖拽操作相关的事件中，事件的 dataTransfer 属性会一直保存着拖拽数据。可使用 getData() 方法来取回数据。

在简单的情况中，你可以使用一个特别的类型 URL 来取回列表中第一个有效的 URL。例如：
`var link = event.dataTransfer.getData("URL");`

URL 类型是一个特别的类型，只作为简写类型，不在 types 属性规定的类型列表中出来。

### 完成拖拽
一旦拖拽完成，dragend 会在拖拽源头即触发 dragstart 的元素上触发。无论拖拽是成功还是被取消，这个事件都会被触发。

如果在 dragend 事件中，dropEffect 属性值为 none，则拖拽会被取消。否则，这个属性会规定需要执行什么操作。
源头元素可使用这个信息以在拖拽操作完成后从原来的位置移除被拖拽的项目。mozUserCancelled 属性会在用户取消拖拽（按下 Esc 键）时设置为 true，
在拖拽因为其他原因如无效放置目标等被取消时，或拖拽成功时，则设置为 false。

放置可发生在同一窗口或另一个应用程序中。两种情况都会触发 dragend 事件。事件的 screenX 和 screenY 属性会被设置为放置发生时鼠标在屏幕上的坐标。

dragend 事件结束后，整个拖放操作就完成了。