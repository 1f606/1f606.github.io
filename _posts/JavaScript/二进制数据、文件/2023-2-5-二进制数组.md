---
layout:     post
title:      二进制数组
subtitle:   
date:       2023-2-5
author:     
header-img: 
catalog: true
tags:
    - ArrayBuffer
    - TypedArray
---
# 二进制数组
在 JavaScript 中二进制操作性能高。

## ArrayBuffer
基本的二进制对象是 ArrayBuffer —— 对固定长度的连续内存空间的引用。

- 它的长度是固定的，无法修改。
- 它正好占用了内存中的那么多空间。
- 要访问单个字节，需要另一个视图对象，而不是通过索引。
- 它是一个内存区域，一个原始的字节序列。

我们这样创建它：
```javascript
let buffer = new ArrayBuffer(16); // 创建一个长度为 16 的 buffer
alert(buffer.byteLength); // 16
```

它会分配一个 16 字节的连续内存空间，并用 0 进行预填充。

如要操作 ArrayBuffer，我们需要使用视图对象。视图用于解释存储在 ArrayBuffer 中的字节。

例如：
- Uint8Array —— 将 ArrayBuffer 中的每个字节视为 0 到 255 之间的单个数字。这称为 “8 位无符号整数”。
（位、字节、字是计算机数据存储的单位。位是最小的存储单位，每一个位存储一个1位的二进制码，一个字节由8位组成。而字通常为16、32或64个位组成。）
- Uint16Array —— 将每 2 个字节视为一个 0 到 65535 之间的整数。这称为 “16 位无符号整数”。
- Uint32Array —— 将每 4 个字节视为一个 0 到 4294967295 之间的整数。这称为 “32 位无符号整数”。
- Float64Array —— 将每 8 个字节视为一个 5.0x10-324 到 1.8x10308 之间的浮点数。

因此，一个 16 字节 ArrayBuffer 中的二进制数据可以解释为 16 个“小数字”，或 8 个更大的数字（每个数字 2 个字节），或 4 个更大的数字（每个数字 4 个字节），或 2 个高精度的浮点数（每个数字 8 个字节）。
![img.png](/img/ArrayBuffer和视图.png)

ArrayBuffer 是核心对象，是所有的基础，是原始的二进制数据。

但是，如果我们要写入值或遍历它，基本上几乎所有操作 —— 我们必须使用视图（view），例如：
```javascript
let buffer = new ArrayBuffer(16); // 创建一个长度为 16 的 buffer

let view = new Uint32Array(buffer); // 将 buffer 视为一个 32 位整数的序列

alert(Uint32Array.BYTES_PER_ELEMENT); // 每个整数 4 个字节

alert(view.length); // 4，它存储了 4 个整数
alert(view.byteLength); // 16，字节中的大小

// 让我们写入一个值
view[0] = 123456;

// 遍历值
for(let num of view) {
  alert(num); // 123456，然后 0，0，0（一共 4 个值）
}
```

## TypedArray
所有这些视图（Uint8Array，Uint32Array 等）的通用术语是 TypedArray。它们共享同一方法和属性集。

类型化数组的行为类似于常规数组：具有索引，并且是可迭代的。

一个类型化数组的构造器（无论是 Int8Array 或 Float64Array，都无关紧要），其行为各不相同，并且取决于参数类型。

参数有 5 种变体：
```javascript
// 此处 TypedArray 表示 new Int8Array、new Uint8Array 及其他中之一。
new TypedArray(buffer, [byteOffset], [length]);
new TypedArray(object);
new TypedArray(typedArray);
new TypedArray(length);
new TypedArray();
```

1. 如果给定的是 ArrayBuffer 参数，则会在其上创建视图。我们已经用过该语法了。
可选，我们可以给定起始位置 byteOffset（默认为 0）以及 length（默认至 buffer 的末尾），这样视图将仅涵盖 buffer 的一部分。
2. 如果给定的是 Array，或任何类数组对象，则会创建一个相同长度的类型化数组，并复制其内容。
我们可以使用它来预填充数组的数据：

```javascript
let arr = new Uint8Array([0, 1, 2, 3]);
alert( arr.length ); // 4，创建了相同长度的二进制数组
alert( arr[1] ); // 1，用给定值填充了 4 个字节（无符号 8 位整数）
```
3. 如果给定的是另一个 TypedArray，也是如此：创建一个相同长度的类型化数组，并复制其内容。如果需要的话，数据在此过程中会被转换为新的类型。
```javascript
let arr16 = new Uint16Array([1, 1000]);
let arr8 = new Uint8Array(arr16);
alert( arr8[0] ); // 1
alert( arr8[1] ); // 232，试图复制 1000，但无法将 1000 放进 8 位字节中（详述见下文）。
```
4. 对于数字参数 length —— 创建类型化数组以包含这么多元素。它的字节长度将是 length 乘以单个 TypedArray.BYTES_PER_ELEMENT 中的字节数：
```javascript
let arr = new Uint16Array(4); // 为 4 个整数创建类型化数组
alert( Uint16Array.BYTES_PER_ELEMENT ); // 每个整数 2 个字节
alert( arr.byteLength ); // 8（字节中的大小）
```
5. 不带参数的情况下，创建长度为零的类型化数组。
   
我们可以直接创建一个 TypedArray，而无需提及 ArrayBuffer。但是，视图离不开底层的 ArrayBuffer，
因此，除第一种情况（已提供 ArrayBuffer）外，其他所有情况都会自动创建 ArrayBuffer。

如要访问底层的 ArrayBuffer，那么在 TypedArray 中有如下的属性：

- arr.buffer —— 引用 ArrayBuffer。
- arr.byteLength —— ArrayBuffer 的长度。

下面是类型化数组的列表：
- Uint8Array，Uint16Array，Uint32Array —— 用于 8、16 和 32 位的整数。
  - Uint8ClampedArray —— 用于 8 位整数，在赋值时便“固定“其值（见下文）。
- Int8Array，Int16Array，Int32Array —— 用于有符号整数（可以为负数）。
- Float32Array，Float64Array —— 用于 32 位和 64 位的有符号浮点数。

## 资料
[Typed arrays - Binary data in the browser](https://web.dev/webgl-typed-arrays/)