---
layout:     post
title:      垃圾回收
subtitle:   
date:       2023-4-5
author:     sq
header-img: 
catalog: true
tags:
    - 性能优化
---
# 性能优化

## 垃圾回收
### 引用计数
维护了当前变量的引用数，引用数为0时立即被回收。

缺点：会导致循环引用的变量和函数无法回收。计时器占用了很大空间。

标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以
及非活动对象来清除，而引用计数则只需要在引用时计数就可以了

### 标记清除
分为标记和清除两个阶段。先标记所有活动对象，再清除其余未标记对象。

在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了内存碎片。，并且由于剩余空闲内存不是一整块，它是由不同大小内存
组成的内存列表，这就牵扯出了内存分配的问题。

分配策略，First-fit，找到大于等于 size 的块立即返回，仍是一个 O(n) 的操作。

缺点：内存碎片化，分配速度慢。

### 标记整理
它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。

### V8的垃圾回收
现在大多数浏览器都是基于标记清除算法，V8 页是，但 V8 对其进行了一些优化加工处理。

#### 分代式垃圾回收
垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，
因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，分代式垃圾回收就是解决这个问题。

##### 新生代
新生代内存区分为使用空间 from 和空闲空间 to两个等大空间。

主要采用复制和标记整理。

活动对象存储在 from，当达到一定条件，就会触发标记整理，将活动对象拷贝至 to。from 和 to 交换空间完成释放。

一轮 GC 后还存活的新生代或 to 空间的使用率超过25%就会晋升，移动到老生代。

##### 老生代
老生代就是存活时间较长的对象

主要采用标记清除、标记整理和增量标记算法。

首先使用标记清除完成垃圾空间的回收，其次在新生代晋升时如果老生代空间不足，就会采用标记整理进行空间优化，还会采用增量标记提升回收效率。

https://juejin.cn/post/6981588276356317214#heading-8
