---
layout:     post
title:      小程序指南
subtitle:   
date:       2022-11-06
author:     
header-img: 
catalog: true
tags:
    - 小程序
---
# 小程序
## 指南

#### 获取节点信息
[节点信息查询和布局相交状态](https://developers.weixin.qq.com/miniprogram/dev/framework/view/selector.html)

#### JS
##### 小程序注册
注册小程序。App() 必须在 app.js 中调用，必须调用且只能调用一次。
##### 路由方式、页面栈、生命周期
页面重定向-当前页面出栈，新页面入栈

Tab 切换、重加载-页面全部出栈，只留下新的 Tab 页面

出栈的页面都会触发onUnload，除了tabbar页面触发onHide
###### Router
页面路由器对象。可以通过 this.pageRouter 或 this.router 获得当前页面或自定义组件的路由器对象。
但如果在自定义组件中调用， this.pageRouter 将相对于自定义组件所在的页面来进行路由跳转，而 this.router 相对于自定义组件自身的路径。

页面路由器有 switchTab reLaunch redirectTo navigateTo navigateBack 五个方法，与 wx 的同名方法功能相同，区别在页面路由的方法调用时是相对于 this 指代的页面或组件。
##### 模块化
JS文件通过 module.exports 或者 exports 对外暴露接口。require引入。<br>
小程序不支持node_modules，需要拷贝相关代码到小程序目录或使用小程序支持的npm

### JS支持情况
- 不支持使用 eval
- 不支持使用new Function（除new Function () {return this;}外）
- 高级语法需要[代码转化工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#es6-%E8%BD%AC-es5)
- Proxy在部分低版本客户端无法被polyfill
- iOS 环境下的 Promise 是一个使用 setTimeout 模拟的 Polyfill，因为 iOS JavaScriptCore 限制。

当指定特定小程序基础库版本时（可以在 小程序管理页 【设置】-【基本设置】-【基础库最低版本设置】中设置）
### 搜索索引
[sitemap](https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html)
### 场景值
[场景值](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/scene.html)

### 自定义组件






##### 外部样式类
在 Component 中用 externalClasses 定义段定义若干个外部样式类属性。这个样式类本身写在页面中而非组件的实现中。
使用时在标签上通过该属性传入自定义class。

注意：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。
##### 引用页面或父组件的样式
即使启用了样式隔离 isolated ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。
通过在类名前加“~”引用页面样式，通过“^“引用父组件样式，也可以连续使用多个 ^ 来引用祖先组件中的样式。

注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式。
#### wxml
支持slot标签。但默认只支持一个，要使用多个需要设置multipleSlots。
```javascript
Component({
  options: {
    multipleSlots: true
  },
  properties: { /* ... */ },
  methods: { /* ... */ }
})
```
#### 虚拟化组件节点-去掉组件使用时多加的包裹节点
默认情况下，自定义组件本身的那个节点是一个“普通”的节点，使用时可以在这个节点上设置 class style 、动画、 flex 布局等，就如同普通的 view 组件节点一样。
但有些时候希望自定义组件内部的第一层节点能够响应 flex 布局或者样式由自定义组件本身完全决定。就是组件使用时会有一个标签包裹着组件，等于是把这个包裹标签去掉。

通过设置virtualHost来实现：
```javascript
Component({
  options: {
    virtualHost: true
  },
  properties: {
    style: { // 定义 style 属性可以拿到 style 属性上设置的值
      type: String,
    }
  },
  externalClasses: ['class'], // 可以将 class 设为 externalClasses
})
```
需要注意的是，自定义组件节点上的 class style 和动画将不再生效，但仍可以：
- 将 style 定义成 properties 属性来获取 style 上设置的值；
- 将 class 定义成 externalClasses 外部样式类使得自定义组件 wxml 可以使用 class 值。

#### 生命周期
##### 页面生命周期
在 `Page({})` 中定义。

[Page参数](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html)

##### 组件生命周期
生命周期方法可以直接定义在 Component 构造器的第一级参数中。

推荐在 Component 构造器的第一级参数中 lifetimes 字段内进行声明，其优先级最高。

注意：
- created 时不能调用 setData

##### 组件所在页面的生命周期
组件所在页面的生命周期在 pageLifetimes 定义段中定义。

注意：自定义 tabBar 的 pageLifetime 不会触发。

[可用的全部生命周期列表](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html)

#### behaviors
##### 自定义behaviors
与 Vue mixins 类似，在组件的 behaviors 字段中定义。同名字段的覆盖和组合规则：

- 同名属性或方法：组件覆盖behaviors；靠后定义的behaviors覆盖靠前的；behaviors覆盖被其引用的behaviors。
- 同名数据：对象类型合并；其余情况会进行数据覆盖，覆盖规则为： 引用者 behavior > 被引用的 behavior 、 靠后的 behavior > 靠前的 behavior。
- 生命周期函数和 observers 不会相互覆盖，而是在对应触发时机被逐个调用：behavior 优先于组件执行； 被引用的 behavior 优先于 引用者 behavior 执行； 靠前的 behavior 优先于 靠后的 behavior 执行。

##### 内置behaviors
自定义组件可以通过引用内置的 behavior 来获得内置组件的一些行为。
https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html#%E5%86%85%E7%BD%AE-behaviors
##### 组件扩展
Behaviors选项对象的definitionFilter函数，接收两个参数，第一个参数是使用该 behavior 的 component 的定义对象，第二个参数是该 behavior 所使用的 behavior 的 definitionFilter 函数列表。

组件扩展提供了修改自定义组件定义段的能力。例如实现computed。

https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/extend.html
#### 组件通信
##### 获取组件实例
可在父组件里调用 this.selectComponent ，获取子组件的实例对象。如：this.selectComponent(selector)。

selector语法可参考https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.select.html

小程序与插件之间、不同插件之间的组件将无法通过 selectComponent 得到组件实例（将返回 null），如果想让组件在上述情况下依然能被返回，可使用内置 behavior: wx://component-export
使用该 behavior 时，自定义组件中的 export 定义段将用于指定组件被 selectComponent 调用时的返回值。
```javascript
Component({
  behaviors: ['wx://component-export'],
  export() {
    return { myField: 'myValue' }
  }
})
```
##### 事件
[冒泡和非冒泡事件列表](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3)<br>
bindtap可以写成bind:tap，catchtap会阻止冒泡，mut-bind绑定互斥事件，整个事件触发过程中，只触发一个mut-bind，不影响bind和catch。<br>
capture-bind、capture-catch关键字，将中断捕获阶段和取消冒泡阶段。<br>
[事件对象](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1)<br>

mark 会包含从触发事件的节点到根节点上所有的 mark: 属性值；而 dataset 仅包含一个节点的 data- 属性值。

mark细节：
- 如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。
- 在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark 。
- 不同于 dataset ，节点的 mark 不会做连字符和大小写转换。
  [WXS响应事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html)<br>

自定义组件触发事件调用triggerEvent。
##### relations
relations 可以让我们拿到父节点、子节点实例。但是注意：必须在两个组件定义中都加入 relations 定义，否则不会生效。例如：
```html
<custom-ul>
  <custom-li> item 1 </custom-li>
  <custom-li> item 2 </custom-li>
</custom-ul>
```
```javascript
Component({
  relations: {
    './custom-li': {
      type: 'child', // 关联的目标节点应为子节点
      linked: function(target) {
        // 每次有 custom-li 被插入时执行，target是该节点实例对象，触发在该节点 attached 生命周期之后
      },
      linkChanged: function(target) {
        // 每次有 custom-li 被移动后执行，target是该节点实例对象，触发在该节点 moved 生命周期之后
      },
      unlinked: function(target) {
        // 每次有 custom-li 被移除时执行，target是该节点实例对象，触发在该节点 detached 生命周期之后
      }
    }
  },
  methods: {
    _getAllLi: function(){
      // 使用 getRelationNodes 可以获得 nodes 数组，包含所有已关联的custom-li，且是有序的
      var nodes = this.getRelationNodes('path/to/custom-li')
    }
  },
  ready: function(){
    this._getAllLi()
  }
})
```
```javascript
Component({
  relations: {
    './custom-ul': {
      type: 'parent', // 关联的目标节点应为父节点
      linked: function(target) {
        // 每次被插入到 custom-ul 时执行，target是 custom-ul 节点实例对象，触发在 attached 生命周期之后
      },
      linkChanged: function(target) {
        // 每次被移动后执行，target是 custom-ul 节点实例对象，触发在 moved 生命周期之后
      },
      unlinked: function(target) {
        // 每次被移除时执行，target是 custom-ul 节点实例对象，触发在 detached 生命周期之后
      }
    }
  }
})
```
还可以通过拥有相同的behaviors来关联。
```html
<custom-form>
  <view>
    input
    <custom-input></custom-input>
  </view>
  <custom-submit> submit </custom-submit>
</custom-form>
```
```javascript
var customFormControls = require('./custom-form-controls')
Component({
  behaviors: [customFormControls],
  relations: {
    './custom-form': {
      type: 'ancestor', // 关联的目标节点应为祖先节点
    }
  }
})
```
```javascript
var customFormControls = require('./custom-form-controls')
Component({
  behaviors: [customFormControls],
  relations: {
    './custom-form': {
      type: 'ancestor', // 关联的目标节点应为祖先节点
    }
  }
})
```
```javascript
var customFormControls = require('./custom-form-controls')
Component({
  relations: {
    'customFormControls': {
      type: 'descendant', // 关联的目标节点应为子孙节点
      target: customFormControls
    }
  }
})
```
relations具体选项：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/relations.html
#### observers数据监听器
即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
数据监听器和属性的 observer 相比，数据监听器更强大且通常具有更好的性能。
```javascript
Component({
  attached: function() {
    this.setData({
      numberA: 1,
      numberB: 2,
    })
  },
  observers: {
    '**': function() {
      // 每次 setData 都触发
    },
    'some.field.**': function(field) {
      // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      field === this.data.some.field
    },
    'some.subfield': function(subfield) {
      // 使用 setData 设置 this.data.some.subfield 时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      subfield === this.data.some.subfield
    },
    'arr[12]': function(arr12) {
      // 使用 setData 设置 this.data.arr[12] 时触发
      // （除此以外，使用 setData 设置 this.data.arr 也会触发）
      arr12 === this.data.arr[12]
    },
    'numberA, numberB': function(numberA, numberB) {
      // 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({
        sum: numberA + numberB
      })
    }
  }
})
```
#### 纯数据字段
纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能，仅在组件内部使用。
指定“纯数据字段”的方法是在 Component 构造器的 options 定义段中指定 pureDataPattern 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。

也可以在页面或自定义组件的 json 文件中配置 pureDataPattern。
```javascript
Component({
  options: {
    pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段
  },
  data: {
    a: true, // 普通数据字段
    _b: true, // 纯数据字段
  },
  methods: {
    myMethod() {
      this.data._b // 纯数据字段可以在 this.data 中获取
      this.setData({
        c: true, // 普通数据字段
        _d: true, // 纯数据字段
      })
    }
  }
})
```
上述组件中的纯数据字段不会被应用到 WXML 上：
```html
<view wx:if="{{a}}"> 这行会被展示 </view>
<view wx:if="{{_b}}"> 这行不会被展示 </view>
```
属性也可以被指定为纯数据字段，示例：
```javascript
Component({
  options: {
    pureDataPattern: /^_/
  },
  properties: {
    a: Boolean,
    _b: {
      type: Boolean,
      observer() {
        // 不要这样做！这个 observer 永远不会被触发，使用 数据监听器 代替。
      }
    },
  }
})
```
#### 抽象节点
有时，自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。

selectable-group组件wxml：
```javascript
<view wx:for="{{labels}}">
  <label>
    <selectable disabled="{{false}}"></selectable>
    {{item}}
  </label>
</view>
```

组件JSON定义：
```json
{
  "componentGenerics": {
    "selectable": true
  }
}
```

或定义默认节点：
```json
{
  "componentGenerics": {
    "selectable": {
      "default": "path/to/default/component"
    }
  }
}
```

组件使用：
```html
<selectable-group generic:selectable="selectable" />
```

节点的 generic 引用 generic:xxx="yyy" 中，值 yyy 只能是静态值，不能包含数据绑定。因而抽象节点特性并不适用于动态决定节点名的场景。

```json
{
  "usingComponents": {
    "selectable": "./component/selectable"
  }
}
```

#### 占位组件
在组件不可用时，会渲染占位组件，而不会报错。
```json
{
  "componentPlaceholder": {
    "comp-a": "view",
    "comp-b": "comp-c"
  }
}
```
### 页面间通信
如果一个页面由另一个页面通过 wx.navigateTo 打开，这两个页面间将建立一条数据通道：

- 被打开的页面可以通过 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象；
- wx.navigateTo 的配置项 success 的参数有一个属性`eventChannel`，是 EventChannel 对象。

这两个 EventChannel 对象间可以使用 emit 和 on 方法相互发送、监听事件。
### 数据更新
#### setData
支持两个参数，改变的数据和回调函数。

data对象，其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如 array\[ 2 \].message，a.b.c.d，并且不需要在 this.data 中预先定义。

仅支持设置可 JSON 化的数据，且大小不超过1024 KB，值不能是 undefined。

## wxml
### 语法
1. WXML 节点标签名只能是小写字母、中划线和下划线的组合。
2. 所有组件与属性都是小写，以连字符-连接。
3. 组件的公共属性：id，class，style，hidden，data-*，bind* / catch*。
4. 双花括号支持运算、关键字、组合，不会读取不存在的属性而报错（存疑）
5. 花括号和引号之间如果有空格，将最终被解析成为字符串
```html
<view wx:for="{{[1,2,3]}} ">
    {{item}}
</view>
<!--等同于-->
<view wx:for="{{[1,2,3] + ' '}}">
    {{item}}
</view>
```

#### 常见语法
```html
<!--组合-->
<view wx:for="{{[zero, 1, 2, 3, 4]}}"> {{item}} </view>
<!--对象的处理 变量名相同的情况，后边的会覆盖前面-->
<!--最终组合成的对象是 {for: 1, bar: 2}-->
<template is="objectCombine" data="{{for: a, bar: b}}"></template>
<!--key 和 value 相同时-->
<template is="objectCombine" data="{{for, bar}}"></template>
<!--扩展运算符-->
<template is="objectCombine" data="{{...obj1, ...obj2, e: 5}}"></template>
<!--双向绑定-->
<custom-component model:my-value="{{pageValue}}" />
```
```javascript
Page({
  data: {
    message: 'h',
    array: [1, 2, 3, 4, 5],
    zero: 0
  }
})
```
#### wx:for
1. wx:for 的值是字符串时，会被解析为调用 split('')后的数组。
2. wx:for-item 定义循环项变量名，wx:for-index 定义循环项索引
3. wx:key 支持两种定义形式。*this 和循环项的某个属性名

```html
<view wx:for="{{array}}">{{index}}{{item}}</view>

<!--item 本身作为key-->
<view wx:for="{{array}}" wx:key="*this">{{index}}{{item}}</view>
<!--item.name 作为key-->
<view wx:for="{{array}}" wx:key="name">{{index}}{{item}}</view>

<view wx:for="{{array}}" wx:for-item="child" wx:for-index="i">{{i}}{{child}}</view>
```
#### 条件渲染
wx:if 控制元素是否渲染，设置 hidden 的元素始终会渲染，只是控制元素显示与隐藏。
```html
<view wx:if="{{view === 'WEBVIEW'}}">webview</view>
<view wx:elif="{{view === 'WEBVIEW'}}">webview</view>
<view wx:else="{{view === 'WEBVIEW'}}">webview</view>
```

#### template
可复用的代码片段。

定义：name 属性定义模板名称，然后在 template 标签内定义模板内容。
使用：is 属性声明使用的模板名称。data 属性传入 template 使用的变量。
```javascript
<!--模板定义-->
<!-- item.wxml -->
<templat name="msgItem">
  <view>
    <text>1</text>
  </view>
</templat>
<!--模板使用-->
<import src="item.wxml"/>
<template is="msgItem" data="{{...item}}"/>
<template is="msgItem" data="{{text: 'test text'}}"/>
<template is="{{item % 2 == 0 ? 'even' : 'odd'}}"/>
```
1. import只引用目标文件定义的template，不会一直递归引用。
2. 模板拥有自己的作用域，只能使用 data 传入的数据以及模板定义文件中定义的 <wxs /> 模块。

#### include
include标签可以将目标文件除了 <template/> <wxs/> 外的整个代码引入，相当于是拷贝到 include 位置。

#### block
类似 block wx:if，也可以将 wx:for 用在<block/>标签上，以渲染一个包含多节点的结构块。例如：
```html
<block wx:for="{{[1, 2, 3]}}">
  <view> {{index}}: </view>
  <view> {{item}} </view>
</block>
```
## wxs
每一个 .wxs 文件和 <wxs> 标签都是一个单独的模块，而且是单例。一个模块要想对外暴露其内部的私有变量与函数，只能通过 module.exports 实现。

wxs 文件可以被 wxs 标签或 wxs 文件中的 require 以相对路径引用。
```html
<wxs src="./../tools.wxs" module="tools" />
```
```javascript
var tools = require("./tools.wxs");
```

单个 wxml 文件内，重名模块名后者覆盖前者。模块命名必须是英语字母、下划线或数字，不能以数字开头。

注意事项（不理解）
- <wxs> 模块只能在定义模块的 WXML 文件中被访问到。使用 `<include>` 或 `<import>` 时，`<wxs>` 模块不会被引入到对应的 WXML 文件中。
- <template> 标签中，只能使用定义该 <template> 的 WXML 文件中定义的 `<wxs>` 模块。

## 组件
### root-portal
root-portal 解决了元素 z-index 受父级 z-index 的问题。
```html
<view style="position: relative; z-index: 10;">test</view>
<view style="position: relative; z-index: 1;">
    <view style="position: absolute; z-index: 100;">受父级影响，无法达到比 test 更高的层级</view>
</view>
```
将该元素作为 root-portal 的子元素就能解决这个问题
```html
<view style="position: relative; z-index: 10;">test</view>
<root-portal wx:if="{{show}}">
    <view style="position: relative; z-index: 1;">
        <view style="position: absolute; z-index: 100;">受父级影响，无法达到比 test 更高的层级</view>
    </view>
</root-portal>
```
### 变量
- WXS 中的变量均为值的引用。
- 没有声明的变量直接赋值使用，会被定义为全局变量。
- 如果只声明变量而不赋值，则默认值为 undefined。
- var表现与 javascript 一致，会有变量提升。
- 命名和模块命名规则一致。部分关键字不能作为变量名。

### 支持的数据类型和全局变量
wxs 中支持的数据类型和数据类型对应的方法和 JavaScript 中支持的不一定相同。

https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/06datatype.html
https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/07basiclibrary.html

## 原生组件
小程序中的部分组件是由客户端创建的原生组件。

* camera
* canvas
* input（仅在focus时表现为原生组件）
* live-player
* live-pusher
* map
* textarea
* video

### 原生组件的使用限制
* 原生组件层级最高，无论 `z-index` 多少。后插入原生组件可以覆盖之前的。
* 原生组件无法在 picker-view、scroll-view、swiper 和 movable-view 中使用
* 部分 CSS 样式无法应用。如 CSS 动画，position: fixed 和 父组件使用 overflow: hidden 裁剪原生组件显示区域
* 原生组件的事件监听不能使用 bind:eventname 的写法，只支持 bindeventname。原生组件也不支持 catch 和 capture 的事件绑定方式。
* 原生组件可通过 bindrendererror 事件监听同层渲染失败的情况并进行降级处理。 同层渲染失败通常由以下原因造成：
  * Android 端运行环境缺少同层渲染所需的内核
  * iOS 端由于实现方式的限制，在页面节点树不稳定的情况下存在一定的失败率

### 原生组件同层渲染
同层渲染是为了解决原生组件的层级问题。

需要注意的是，组件内部仍由原生渲染，样式一般还是对原生组件内部无效。当前所有原生组件（除 input 组件 focus 状态）均已支持同层渲染。

除事件相关，同层渲染下已无以上限制。

### 原生组件间层级
支持在样式中声明 z-index 来指定原生组件的层级。该 z-index 仅调整原生组件之间的层级顺序，其层级仍高于其他非原生组件。

## TODO
- 响应显示区域变化。屏幕旋转，尺寸不同的设备的显示。https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html
- 分栏模式。https://developers.weixin.qq.com/miniprogram/dev/framework/view/frameset.html
- 动画。https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html
- 初始渲染缓存。https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html
- 小程序运行机制。https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html
- 更新机制。https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/update-mechanism.html
- skyline渲染引擎
- 从插件开始没看
- replaceDataOnPath 和 applyDataUpdates 方法。https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html


# 指南
## 小程序基础概念
### 小程序注册
[小程序注册页](https://mp.weixin.qq.com/wxopen/waregister?action=step1)，注册后在后台能拿到小程序的AppID。

小程序的 AppID 相当于小程序平台的一个身份证，和服务号或订阅号的 AppID有区别。

### 代码构成
页面由四个类型的文件构成 json，wxss，wxml 和 js。

json 文件属于配置文件，定义了全局范围（或页面范围）界面表现、网络超时时间、底部 tab 等。

js 文件是写生命周期方法，模板所使用的方法的地方。

wxss 定义全局或页面样式。

wxml 编写页面 html。

在项目根目录下，app.json, app.wxss 和 app.js 文件影响全局。每个页面也有对应的 json，js，wxml 和 wxss 文件。

### 一些特殊文件
工具配置 project.config.json 。小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，其中会包括编辑器的颜色、代码上传时
自动压缩等等一系列[选项](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)。

页面配置 page.json。page.json让开发者可以独立定义每个页面的一些属性，覆盖app.json中的[配置](https://developers.weixin.qq.com/miniprogram/dev/reference/)。

小程序添加新页面需要在 page.json 的 pages 字段添加对应页面文件夹的路径。

### 小程序运行环境
小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用 JsCore 线程运行 JS 脚本。

一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由 Native 转发。

开启ES6转ES5和样式补全，因为各平台[运行环境](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/env.html)不同，导致有部分差异，具体表现以客户端为准。

## wxss
WXSS 具有 CSS 大部分的特性，也做了一些扩充和修改。
1. 新增尺寸单位rpx。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。
2. 仅支持部分css选择器。类、元素、ID、逗号，before和after伪元素。
3. 样式导入。使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。
4. 静态的样式统一写到 class 中。style 接收动态的样式，避免影响渲染速度。

## WXS
WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。

WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。

从基础库版本2.4.4开始，支持使用 WXS 函数绑定事件

由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。

### wxs 是一个模块
WXS 代码可以编写在 wxml 文件中的` <wxs> `标签内，或以 .wxs 为后缀名的文件内。

每一个 .wxs 文件和 `<wxs>` 标签都是一个单独的模块。

每个模块都有自己独立的作用域，默认为私有的。一个模块要想对外暴露其内部的私有变量与函数，只能通过设置 `module.exports` 实现。

### 引入
可以通过 wxs 标签或 require 函数引入 wxs模块。

引用的时候，要注意如下几点：
* 只能引用 .wxs 文件模块，且必须使用相对路径。
* wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。
* 如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。
* `<wxs>` 模块只能在定义模块的 WXML 文件中被访问到。使用 `<include>` 或 `<import>` 时，`<wxs>` 模块不会被引入到对应的 WXML 文件中。
* `<template>` 标签中，只能使用定义该 `<template>` 的 WXML 文件中定义的 `<wxs>` 模块。

```html
<wxs src="../tool.wxs" module="tool"/>
<view>{{tool.msg}}</view>
```

在wxs模块引入：
```javascript
var tools = require("./tools.wxs");

console.log(tools.FOO);
```

### wxs 标签
module是模块名，必填，在当前文件内值要唯一，否则后者覆盖前者。

module 必须是 a-zA-Z或下划线_和0-9组成。数字不能作为开头。

### require函数
在.wxs模块中引用其他 wxs 文件模块，可以使用 require 函数。

### 变量
1. 有部分保留关键字 
2. WXS 中的变量均为值的引用。 
3. 没有声明的变量直接赋值使用，会被定义为全局变量。 
4. 如果只声明变量而不赋值，则默认值为 undefined。 
5. var表现与javascript一致，会有变量提升。
6. 命名必须是 a-zA-Z或下划线_和0-9组成。数字不能作为开头。

### 注释
```javascript
<wxs module="sample">
// 方法一：单行注释

/*
方法二：多行注释
*/

/*
方法三：结尾注释。即从 /* 开始往后的所有 WXS 代码均被注释
```

### 类型
生成 date 对象需要使用 getDate函数, 返回一个当前时间的对象。

生成 regexp 对象需要使用 getRegExp函数。

wxs 的基本类库：https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/07basiclibrary.html

wxs 的运算符：https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/04operator.html

## 获取节点信息
`wx.createSelectorQuery` 可以用于获取节点属性、样式、在界面上的位置等信息。

常见例子：
```javascript
const query = wx.createSelectorQuery()
query.select('#the-id').boundingClientRect(function(res){
  res.top
})
query.selectViewport().scrollOffset(function(res){
  res.scrollTop
})
query.exec()
```

selectorQuery 实例对象的 `select` 方法接收选择器，返回在当前页面下选择第一个匹配选择器 selector 的节点 - [NodesRef](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/NodesRef.html)。
`NodesRef` 有相应获取几何属性和位置的方法。

`select` 方法支持以下选择器：ID选择器 ，class选择器（可以连续指定多个） ，子元素选择器 ，后代选择器 ，跨自定义组件的后代选择器 ，多选择器的并集

注意：在自定义组件或包含自定义组件的页面中，推荐使用 this.createSelectorQuery 来代替 wx.createSelectorQuery ，这样可以确保在正确的范围内选择节点。

## setData
支持的更新方式：
```js
// 已定义数据
page({
  data: {
    obj: {
      name: '1'
    },
    arr: ['1', '2']
  }
})

this.setData({
  ['obj.name']: 2,
  ['arr[0]']: 1
});
```

## 组件
在json文件中，设置component为true可将这一组文件设置为自定义组件。在js文件中，用Component 而不是 Page 方法注册。

引入：
```json
{
  "usingComponents": {
    "custom-component-tag-name": "path/to/componentFolderName/componentName"
  }
}
```

注意：
- 因为 WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
- 自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。
- 是否在页面文件中使用 usingComponents 会使得页面的 this 对象的原型稍有差异，包括：
  - 使用 usingComponents 页面的原型与不使用时不一致，即 Object.getPrototypeOf(this) 结果不同。
  - 使用 usingComponents 时会多一些方法，如 selectComponent 。
  - 出于性能考虑，使用 usingComponents 时， setData 内容不会被直接深复制，即 this.setData({ field: obj }) 后 this.data.field === obj 。（深复制会在这个值被组件间传递时发生。）

### component构造函数
自定义组件使用的是 Component 构造函数，页面也可以使用 Component 构造函数，但此时要求对应 json 文件中包含 usingComponents 定义段。

此时properties可用于接收路由跳转传递的参数。页面的生命周期方法（即 on 开头的方法），应写在 methods 定义段中。

使用 Component 构造器来构造页面的一个好处是可以使用 behaviors 来提取所有页面中公用的代码段。

### 样式
在组件 wxss 中有部分限制：
- 不能使用 ID 选择器、属性选择器和标签名选择器
- 不应使用后代选择器，某些情况会有非预期表现
- 子元素选择器只能用于view组件与其子节点间，用于其他情况会有非预期表现。
- 继承样式。如 font 、 color ，会从组件外继承到组件内。
- app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。

组件可以指定它所在节点的默认样式，使用 :host 选择器。

#### 样式隔离
默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：
- app.wxss 或页面的 wxss 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。
- 指定特殊的样式隔离选项 styleIsolation 。

可以在 js 的 options 对象中和 json 文件中设置 styleIsolation。

如果这个 Component 构造器用于构造页面 ，则默认值为 shared。会有几个额外选项可选。

[styleIsolation详细选项](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html#%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB)

小程序基础库版本 2.2.3 以上支持 addGlobalClass 选项，即在 Component 的 options 中设置 addGlobalClass: true 。 这个选项等价于设置 
styleIsolation: apply-shared ，但设置了 styleIsolation 选项后这个选项会失效。
