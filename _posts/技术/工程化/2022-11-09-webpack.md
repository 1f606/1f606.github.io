---
layout:     post
title:      webpack
subtitle:   
date:       2022-11-08
author:     sq
header-img: 
catalog: true
tags:
    - Webpack
---
# webpack
## Webpack打包流程
- 输入：从文件系统读入代码文件；
- 模块递归处理：调用 Loader 转译 Module 内容，并将结果转换为 AST，从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；
- 后处理：所有模块递归处理完毕后开始执行后处理，包括模块合并、注入运行时、产物优化等，最终输出 Chunk 集合；
- 输出：将 Chunk 写出到外部文件系统；
## webpack配置方式
- 单个配置对象：比较常用的一种方式，逻辑简单，适合大多数业务项目；
- 配置对象数组：每个数组项都是一个完整的配置对象，每个对象都会触发一次单独的构建，通常用于需要为同一份代码构建多种产物的场景，如 Library；
- 函数：Webpack 启动时会执行该函数获取配置，我们可以在函数中根据环境参数(如 NODE_ENV)动态调整配置对象。

### 数组方式
```javascript
// webpack.config.js
module.exports = [{
  name: 'amd',
  entry: './src/index.js',
  // 其它配置...
}, {
  entry: './src/index.js',
  // 其它配置...
}];
```
> 提示：使用配置数组时，还可以通过 --config-name 参数指定需要构建的配置对象，例如上例配置中若执行 npx webpack --config-name='amd'，则仅使用数组中 name='amd' 的项做构建。

### 函数方式
配置函数方式要求在配置文件中导出一个函数，并在函数中返回 Webpack 配置对象，或配置数组，或 Promise 对象，如：
```javascript
module.exports = function(env, argv) {
  // ...
  return {
    entry: './src/index.js',
    // 其它配置...
  }
}
```
运行时，Webpack 会传入两个环境参数对象：

- env：通过 --env 传递的命令行参数，适用于自定义参数，例如：

|命令：|env 参数值：|
|----|----|
|npx webpack --env prod|{ prod: true }|
|npx webpack --env prod --env min|{ prod: true, min: true }|
|npx webpack --env platform=app --env production|{ platform: "app", production: true }|
|npx webpack --env foo=bar=app|{foo: "bar=app"}|
|npx webpack --env app.platform="staging" --env app.name="test"|npx webpack --env app.platform="staging" --env app.name="test"|
- argv：命令行 [Flags](https://webpack.js.org/api/cli/#flags) 参数，支持 entry/output-path/mode/merge 等。

## babel
Webpack 场景下，只需使用 babel-loader 即可接入 Babel 转译功能

@babel/preset-env 是一种 Babel 预设规则集，内置了一系列polyfill、插件等。Preset 是 Babel 的主要应用方式之一，不同应用场景有不同 Preset 资源。

@babel/core是babel转码的核心依赖。
## typescript
Webpack 有很多种接入 TypeScript 的方法，包括 ts-loader、awesome-ts-loader、 babel-loader+@babel/preset-typescript。通常可使用 ts-loader 构建 TypeScript 代码。

注意：@babel/preset-typescript 只是简单完成代码转换，并未做类似 ts-loader 的类型检查工作。
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: {
          loader: 'babel-loader',
          options: { presets: ['@babel/preset-typescript'] }
        }
      }
    ]
  }
}
```
## eslint
```shell
npm install --save-dev eslint eslint-webpack-plugin eslint-config-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-n
```
.eslintrc文件配置
```
{
  "extends": "standard"
}
```
webpack配置
```
module.exports = {
  plugins: [new ESLintPlugin()]
}
```
## eslint+typescript+babel
```shell
npm i -D webpack webpack-cli @babel/core @babel/preset-env babel-loader @babel/preset-typescript typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint eslint-webpack-plugin
```
.eslintrc配置
```json
{
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "extends": ["plugin:@typescript-eslint/recommended"]
}
```
```javascript
module.exports = {
  // ...
  plugins: [new ESLintPlugin({ extensions: ['.js', '.ts'] })]
}
```
## 处理样式
常用loader或plugin：
- css-loader：该 Loader 会将 CSS 等价翻译为形如 module.exports = "${css}" 的JavaScript 代码，使得 Webpack 能够如同处理 JS 代码一样解析 CSS 内容与资源依赖；
- style-loader：该 Loader 将在产物中注入一系列 runtime 代码，这些代码会将 CSS 内容注入到页面的 style 标签，使得样式生效；
- mini-css-extract-plugin：该插件会将 CSS 代码抽离到单独的 .css 文件，并将文件通过 <link> 标签方式插入到页面中。提供 Loader、Plugin 组件，需要同时使用。

### css-loader+style-loader
问题：
- JS、CSS 资源无法并行加载，从而降低页面性能；
- 资源缓存粒度变大，JS、CSS 任意一种变更都会致使缓存失效。

### css-loader + mini-css-extract-plugin
```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const HTMLWebpackPlugin = require('html-webpack-plugin')

module.exports = {
    module: {
        rules: [{
            test: /\.css$/,
            use: [
                (process.env.NODE_ENV === 'development' ?
                    'style-loader' :
                    MiniCssExtractPlugin.loader),
                'css-loader'
            ]
        }]
    },
    plugins: [
        new MiniCssExtractPlugin(),
        new HTMLWebpackPlugin()
    ]
}
```
### 预处理器
在rules的use数组里的css-loader后加上对应预处理器的loader。
```javascript
module.exports = {
    module: {
        rules: [{
            use: [
                'css-loader', 
              // 预处理器loader
            ]
        }]
    }
}
```
#### postcss
postcss的使用除了postcss postcss-loader的安装外，还需要对应postcss的插件。例如我们可以使用 autoprefixer 插件自动添加浏览器前缀、[postcss-preset-env](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjonathantneal%2Fpostcss-preset-env)转译为兼容性更好的代码。
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          "style-loader", 
          {
            loader: "css-loader",            
            options: {
              importLoaders: 1
            }
          }, 
          {
            loader: "postcss-loader",
            options: {
              postcssOptions: {
                // 添加 autoprefixer 插件
                plugins: [require("autoprefixer")],
              },
            },
          }
          // 或在postcss.config.js配置
          // postcss-loader
        ],
      },
    ],
  }
};
```
## vue项目环境搭建
### 安装vue
```shell
#两个版本要一致
npm i vue
npm i -D vue-template-compiler
```
### vue-loader处理sfc
vue-loader 库同时提供用于处理 SFC 代码转译的 Loader 组件，与用于处理上下文兼容性的 Plugin 组件，两者需要同时配置才能正常运行。
> vue-loader高版本不处理vue2，需要16以下版本

```javascript
const { VueLoaderPlugin } = require("vue-loader");

module.exports = {
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: ["vue-loader"],
      },
    ],
  },
  plugins: [new VueLoaderPlugin()],
};
```
但是sfc里面的style还是需要style-loader和css-loader处理
```javascript
module.exports = {
  rules: [
    // ...
    {
      test: /\.css$/,
      use: ["style-loader", "css-loader"],
    }
  ]
}
```
### HtmlWebpackPlugin生成入口HTML
```shell
yarn add -D html-webpack-plugin
```
```javascript
module.exports = {
  plugins: [
    // ...
    new HtmlWebpackPlugin({
      templateContent: `
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Webpack App</title>
  </head>
  <body>
    <div id="app" />
  </body>
</html>
    `,
    })
  ]
}
```
### webpack-dev-server启动本地开发服务
```shell
npm install -D webpack-dev-server
```
```javascript
module.exports = {
  devServer: {
    hot: true,
    open: true
  }
}
```
```shell
#启动服务
npx webpack serve
```
### sfc加入typescript
```shell
npm install -D typescript ts-loader
```
```javascript
module.exports = {
  rules: [
    // ...
    { test: /\.ts$/, use: ["ts-loader"] }
  ]
}
```
sfc的script标签设置lang = "typescript"。

vue-loader 会根据 lang 属性值，按 Webpack 配置的 TypeScript 规则，调用 ts-loader 处理这部分代码。支持tsconfig.json
> 同理，与处理普通 .ts、.js 文件类似的，我们还可以通过 Webpack 的 module.rule 配置项继续接入 ESLint、Babel、Flow 等工具，这些规则也都会对 Vue SFC 文件模块生效。

### sfc template处理
template的处理规则会稍微不同，因为绝大部分 Webpack 模板类 Loader 都会返回一个模板函数，而不是编译好的 HTML 片段，这与 Vue SFC 将template编译为 render 函数的规则相冲突，此时通常需要使用一个返回原始的 HTML 字符串的 loader，例如使用 pug-plain-loader，而不是 pug-loader。
```shell
yarn add -D pug pug-plain-loader
```
```javascript
module.exports = {
  rules: [
    // ...
    { test: /\.pug$/, use: ["pug-plain-loader"] },
  ]
}
```
设置 template 标签的 lang = " pug"。
## externals peerDependencies
将第三方依赖排除在打包系统之外，避免出现使用者在业务项目中已经安装并使用了该第三方依赖，那么最终产物必然会包含两份第三方依赖代码。

[webpack-node-externals](https://www.npmjs.com/package/webpack-node-externals) 可以排除所有 node_modules 模块，使用方法：
```javascript
// webpack.config.js
const nodeExternals = require('webpack-node-externals');

module.exports = {
  // ...
  externals: [nodeExternals()]
  // ...
};
```
## npm库配置技巧
- 使用 .npmignore 文件忽略不需要发布到 NPM 的文件；
- 在 package.json 文件中，使用 prepublishOnly 指令，在发布前自动执行编译命令，例如：

```json
{
  "scripts": {
    "prepublishOnly": "webpack --mode=production"
  }
}
```
## 如何搭建 React 全栈开发环境？
## 使用 Webpack 构建微前端应用
## 如何借助 Webpack 开发 PWA、Node、Electron 应用？
## 图片
### 打包
#### webpack4
file-loader：将图像引用转换为 url 语句并生成相应图片文件，例如使用如下配置：
```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      use: ['file-loader']
    }],
  },
};
```
url-loader：有两种表现，对于小于阈值 limit 的图像直接转化为 base64 编码；大于阈值的图像则调用 file-loader 进行加载，例如如下配置：
```javascript
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      use: [{
        loader: 'url-loader',
        options: {
          // 单位 B
          limit: 1024
        }
      }]
    }],
  },
};
```
raw-loader：不做任何转译，只是简单将文件内容复制到产物中，适用于 SVG 场景，例如如下配置：
```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.svg$/i,
        use: ['raw-loader'],
      },
    ],
  },
};
```
#### webpack5
内置了[资源模块](https://webpack.js.org/guides/asset-modules/)，不再需要安装上述loader。
### 压缩
在 Webpack 生态中有不少优秀的图像压缩组件，包括：image-webpack-loader、imagemin-webpack-plugin、image-minimizer-webpack-plugin 等，以我的使用经验来看，image-webpack-loader 组件功能齐全且用法简单，更推荐使用。基本用法首先安装依赖：
```javascript
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(gif|png|jpe?g|svg)$/i,
      type: "asset/resource",
      use: [{
        loader: 'image-webpack-loader',
        options: {
          // jpeg 压缩配置
          mozjpeg: {
            quality: 80
          },
        }
      }]
    }],
  },
};
```
image-webpack-loader 底层依赖于 imagemin 及一系列的图像优化工具：
- mozjpeg：用于压缩 JPG(JPEG) 图片；
- optipng：用于压缩 PNG 图片；
- pngquant：同样用于压缩 PNG 图片；
- svgo：用于压缩 SVG 图片；
- gifsicle：用于压缩 Gif 图；
- webp：用于将 JPG/PNG 图压缩并转化为 WebP 图片格式。

注意：图像压缩是一种非常耗时的操作。
### 雪碧图
Webpack 中，我们可以使用 webpack-spritesmith 插件自动实现雪碧图效果。HTTP2 实现 TCP 多路复用之后，雪碧图的优化效果已经微乎其微。
### 响应式图片
为不同设备提供不同的分辨率、不同尺寸的图片，兼顾显示效果和带宽。
Webpack 中有不少能够自动生成响应式图片的组件，例如： resize-image-loader、html-loader-srcset、responsive-loader 等，以 responsive-loader 为例，首先安装依赖：
```shell
yarn add -D responsive-loader sharp
```
```javascript
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      oneOf: [{
        type: "javascript/auto",
        // 过滤出带 size/sizes 参数的图片引用
        resourceQuery: /sizes?/,
        use: [{
          loader: "responsive-loader",
          options: {
            adapter: require("responsive-loader/sharp"),
          },
        }],
      }, {
        type: "asset/resource",
      }],
    }],
  }
};
```

## 性能分析
```javascript
// webpack.config.js
module.exports = {
  // ...
  profile: true
}
```
--json 参数，参数值为最终生成的统计文件名，执行后会生成stats.json文件。
```shell
npx webpack --json=stats.json
```
社区提供的部分优秀分析工具：
- Webpack Analysis ：Webpack 官方提供的，功能比较全面的 stats 可视化工具。
- Statoscope：主要侧重于模块与模块、模块与 chunk、chunk 与 chunk 等，实体之间的关系分析。
- Webpack Visualizer：一个简单的模块体积分析工具，真的很简单！
- Webpack Bundle Analyzer：应该是使用率最高的性能分析工具之一，主要实现以 Tree Map 方式展示各个模块的体积占比。
- Webpack Dashboard：能够在编译过程实时展示编译进度、模块分布、产物信息等。
- Unused Webpack Plugin：能够根据 stats 数据反向查找项目中未被使用的文件。
- Speed Measure Plugin：能够统计出各个 Loader、插件的处理耗时，开发者可以根据这些数据分析出哪些类型的文件处理更耗时间。

## 持久化缓存
### webpack5
https://webpack.js.org/configuration/cache/
### webpack4
原生不支持，只能借助第三方：
- 使用 [cache-loader](https://www.npmjs.com/package/cache-loader)；
- 使用 [hard-source-webpack-plugin](https://github.com/mzgoddard/hard-source-webpack-plugin)；
- 使用 Loader（如 babel-loader、eslint-loader)）自带的缓存能力。

#### cache-loader
仅缓存了 Loader 执行结果。
```shell
yarn add -D cache
```
cache-loader必须在首位。
```javascript
module.exports = {
    // ...
    module: {
        rules: [{
            test: /\.js$/,
            use: ['cache-loader', 'babel-loader', 'eslint-loader']
        }]
    },
    // ...
};
```
#### hard-source-webpack-plugin
不仅仅缓存了 Loader 运行结果，还保存了 Webpack 构建过程中许多中间数据，包括：模块、模块关系、模块 Resolve 结果、Chunks、Assets 等，效果几乎与 Webpack5 自带的 Cache 对齐。

首次运行时，hard-source-webpack-plugin 会在缓存文件夹 node_module/.cache 写入一系列日志文件。
```shell
yarn add -D hard-source-webpack-plugin
```
```javascript
const HardSourceWebpackPlugin = require("hard-source-webpack-plugin");

module.exports = {
  // ...
  plugins: [
    new HardSourceWebpackPlugin(),
  ],
};
```

### 组件自带的缓存能力
还可以使用 Webpack 组件自带的缓存能力提升特定领域的编译性能，这一类组件有：
- babel-loader；
- eslint-loader：旧版本 ESLint Webpack 组件，官方推荐使用 eslint-webpack-plugin 代替；
- eslint-webpack-plugin；
- stylelint-webpack-plugin。

cacheDirectory = true开启。默认情况下，缓存内容会被保存到 node_modules/.cache/babel-loader 目录，你也可以通过 cacheDirectory = 'dir' 属性设置缓存路径。
```javascript
module.exports = {
    // ...
    module: {
        rules: [{
            test: /\.m?js$/,
            loader: 'babel-loader',
            options: {
                cacheDirectory: true,
            },
        }]
    },
    // ...
};
```
ESLint 与 Stylelint 也提供了相应的缓存能力，设置 cache = true 可开启。
```javascript
// webpack.config.js
module.exports = {
  plugins: [
    new ESLintPlugin({ cache: true }),
    new StylelintPlugin({ files: '**/*.css', cache: true }),
  ],
};
```
## 实现并行构建
### happyPack
HappyPack 能够将耗时的文件加载（Loader）操作拆散到多个子进程中并发执行，子进程执行完毕后再将结果合并回传到 Webpack 进程，从而提升构建性能。
不过，HappyPack 的用法稍微有点难以理解，需要同时：

- 使用 happypack/loader 代替原本的 Loader 序列；
- 使用 HappyPack 插件注入代理执行 Loader 序列的逻辑。

```shell
yarn add -D happypack
```
将原有 loader 配置替换为 happypack/loader，如：
```javascript
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: "happypack/loader",
        // 原始配置如：
        // use: [
        //  {
        //      loader: 'babel-loader',
        //      options: {
        //          presets: ['@babel/preset-env']
        //      }
        //  },
        //  'eslint-loader'
        // ]
      },
    ],
  },
};
```
创建 happypack 插件实例，并将原有 loader 配置迁移到插件中，完整配置：
```javascript
const HappyPack = require("happypack");

module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: "happypack/loader",
        // 原始配置如：
        // use: [
        //  {
        //      loader: 'babel-loader',
        //      options: {
        //          presets: ['@babel/preset-env']
        //      }
        //  },
        //  'eslint-loader'
        // ]
      },
    ],
  },
  plugins: [
    new HappyPack({
      // 将原本定义在 `module.rules.use` 中的 Loader 配置迁移到 HappyPack 实例中
      loaders: [
        {
          loader: "babel-loader",
          option: {
            presets: ["@babel/preset-env"],
          },
        },
        "eslint-loader",
      ],
    }),
  ],
};
```
HappyPack支持创建多个实例来加载多种类型，例如：
```javascript
const HappyPack = require('happypack');

module.exports = {
  // ...
  module: {
    rules: [{
        test: /\.js?$/,
        // 使用 `id` 参数标识该 Loader 对应的 HappyPack 插件示例
        use: 'happypack/loader?id=js'
      },
      {
        test: /\.less$/,
        use: 'happypack/loader?id=styles'
      },
    ]
  },
  plugins: [
    new HappyPack({
      // 注意这里要明确提供 id 属性
      id: 'js',
      loaders: ['babel-loader', 'eslint-loader']
    }),
    new HappyPack({
      id: 'styles',
      loaders: ['style-loader', 'css-loader', 'less-loader']
    })
  ]
};
```
