---
layout:     post
title:      鼠标拖拽
subtitle:   
date:       2023-1-10
author:     sq
header-img: 
catalog: true
tags:
    - JavaScript
    - 事件
---
# 鼠标拖拽
## 基础
基础的拖放算法如下所示：
1. 在 mousedown 上 —— 根据需要初始化相关变量等。
2. 然后在 mousemove 上，通过更改 left/top 来移动它。
3. 在 mouseup 上 —— 执行与完成拖放相关的所有行为。

注意：
被拖动元素的 dragstart 和 mousedown 事件需要禁止浏览器的默认行为，否则拖动时会出现不符合预期的行为。

禁止选中也可以通过设置 css 样式
```css
body {
    user-select: none;
}
iframe {
    pointer-events: none;
}
```

例子：
```javascript
elem.onmousedown = function (event) {
  const shiftX = event.clientX - elem.getBoundingClientRect().left;
  const shiftY = event.clientY - elem.getBoundingClientRect().top;
  
  elem.style.position = 'absolute';
  elem.style.zIndex = 1000;
  document.body.append(ball);
  
  moveAt(event.pageX, event.pageY);
  
  function moveAt (pageX, pageY) {
    elem.style.left = pageX - shiftX + 'px';
    elem.style.top = pageY - shiftY + 'px';
  }
  
  function onMouseMove (event) {
    moveAt(event.pageX, event.pageY);
  }
  
  document.addEventListener('mousemove', onMouseMove);
  
  elem.onmouseup = function () {
    document.removeEventListener('mousemove', onMouseMove);
    elem.onmouseup = null;
  }
};

elem.ondragestart = function () {
  return false;
};
```
## 鼠标事件中拿到当前顶层元素
鼠标事件只发生在最顶层元素上，被遮挡的元素无法触发，那么在 mousemove 事件中，我们无法判断是否拖动到了可拖放区域。

解决方法时可以先将当前拖拽元素隐藏，然后调用 document.elementFromPoint(clientX, clientY)，拿到最上层元素后，再显示当前拖拽元素。

因此我们修改 onMouseMove 方法：
```javascript
let currentDroppable = null;
function onMouseMove (event) {
  moveAt(event.pageX, event.pageY);
  
  elem.hidden = true;
  const elemBelow = document.elementFromPoint(event.clientX, event.clientY);
  elem.hidden = false;
  
  if (!elemBelow) return;
  
  const droppableBelow = elemBelow.closest('.droppable');
  if (currentDroppable !== droppableBelow) {
    if (currentDroppable) {
      leaveDroppable(currentDroppable);
    }
    currentDroppable = droppableBelow;
    if (currentDroppable) {
      enterDroppable(currentDroppable);
    }
  }
}
```