---
layout:     post
title:      面试题
subtitle:   
date:       2022-11-05
author:     
header-img: 
catalog: true
tags:
    - 面试
---
# 面试题
## vue
### 对vue的理解
Vue是一个创建单页应用的框架。

核心特性：
1. 数据驱动MVVM。

- Model：模型层。负责处理业务逻辑，泛指后端进行的各种业务逻辑处理和数据操控。
- View：视图层：负责将数据模型转化为UI展示出来。
- ViewModel：视图模型层，通过双向绑定用来连接Model和View。

Vue 框架就是充当了 MVVM 开发模式中的 ViewModel 层，负责 View 和 Model 之间通信的桥梁。开发时只需要关心 View 层的 HTML 代码和 Model 层的 JavaScript 逻辑就可以了。

> MVC
> 
> Model：数据模型，用来存储数据
> 
> View：视图界面，用来展示UI界面和响应用户交互
> 
> Controller：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互

框架的双向绑定让开发者不再需要频繁操作DOM，只需处理好viewModel，视图就会更新，实现数据驱动开发。

ViewModel它的主要职责就是：
- 数据变化后更新视图
- 视图变化后更新数据

当然，它还有两个主要部分组成
- 监听器（Observer）：对所有数据的属性进行监听
- 解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数

2. 组件化

组件化就是把视图和非视图的各种逻辑均抽象为一个统一的概念来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件。

优点是降低了系统耦合度，方便调试和提高了可维护性。
3. 指令系统

指令是带有 v- 前缀的特殊属性，当对应的表达式发生变化，会作用到DOM上。

### 什么是SPA
SPA就是单页应用。通过动态重写当前页面与用户交互，避免了页面之间切换而频繁刷新。

### SPA和MPA区别
MPA中每个页面都是独立的，访问另外一个页面时需要重新加载CSS、HTML和JS。切换页面会整页刷新，对SEO友好。

### 实现SPA
#### hash模式
```javascript
class Router {
  constructor () {
    this.routes = {};
    this.currentUrl = '';
    window.addEventListener('load', this.refresh, false);
    window.addEventListener('hashchange', this.refresh, false);
  }
  route (path, callback) {
    this.routes[path] = callback;
  }
  push (path) {
    this.routes[path] && this.routes[path]();
  }
  refresh () {
    const url = window.location.hash.slice(1);
    this.routes[url] && this.routes[url]();
  }
}
```
#### history模式

history.pushState 浏览器历史纪录添加记录

history.replaceState修改浏览器历史纪录中当前纪录

history.popState 当 history 发生变化时触发

通过history.pushState方法改变地址栏。仅改变url和增加到历史记录中，不会向服务器发起请求。

改变会触发popstate事件。调用pushState和replaceState不会触发这个事件。只有点击浏览器的前进，后退，调用history.back和history.forward的时候才会触发。

#### Vue中hash模式和history模式的区别
- 在显示上，hash模式的URL中会夹杂着#号，而history没有。
- 实现方式不同。hash模式是依靠hashchange事件，而history模式是主要是依靠的HTML5 history中新增的两个方法pushState和replaceState。
- 当真正需要通过URL向后端发送HTTP请求的时候，比如常见的用户手动输入URL后回车，或者是刷新(重启)浏览器，这时候history模式需要后端的支持。
因为history模式下，前端的URL必须和实际向后端发送请求的URL一致，例如有一个URL是带有路径path的(例如www.lindaidai.wang/blogs/id)，
如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面。

### 如何给SPA做SEO优化
1. 服务端渲染，如nuxt
2. 静态化

目前主流的静态化主要有两种：
- 一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中
- 另外一种是通过WEB服务器的 URL Rewrite的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果

3. 使用Phantomjs针对爬虫处理

### SPA首屏加载速度慢
1. 首屏时间计算：new Date.getTime() - performance.timing.navigationStart（在body标签后计算）
2. 白屏时间计算：在`<head>`标签前面加一个`<script>`标签，里面加入上面相同代码。

#### 加载慢的原因
- 网络延时
- 资源体积
- 渲染堵塞

#### 解决方法
- 减小入口文件体积。路由懒加载
- 静态资源本地缓存。HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头
- UI框架按需加载
- 图片资源的压缩 雪碧图、体积压缩、使用在线字体
- 组件重复打包，webpack config minChunks。
- 开启GZip压缩
- 使用SSR
- DNS预解析

### vue中组件和插件的区别
组件是用来构成应用的业务模块，插件是增强技术栈的功能模块

### vue中的通信方式
- 通过 props 传递
- 通过 $emit 触发自定义事件
- 使用 ref
- EventBus
- $parent 或$root
- attrs 与 listeners
- Provide 与 Inject

### vue的优缺点
优点：
- 响应式。不用操作 DOM，把精力更多放在业务逻辑。
- 组件化。可复用部分可以抽离做成组件，提高开发效率，项目可维护性更高。
- 虚拟DOM。性能提升

缺点：
- 不利于SEO
- 导航不可用，需要自己实现前进后退。
- 初次加载耗时较长

### 指令

### 响应式原理

#### 数组的处理

### key, diff算法


## css
### inline, inline block 和 block 区别
- block 前后都有换行符，能设置宽高和内外边距。
- inlin-block，前后无换行符，能设置宽高和内外边距。
- inline，前后无换行符，无法设置宽高，margin水平方向有效，padding水平垂直都有效。

### link 标签和 @import 的区别
- 页面被加载时，link 标签会同时被加载，而@import 引用的 css 会等到页面加载结束后加载。
- @import 在 IE5 以上才支持，link 标签没有兼容性问题。

### 层叠上下文
当 z-index 为数值并且生效的时候，容器会发生一种变化，会使得容器内的子组件无法穿过容器本身，并且子组件的层级由父组件决定。这种变化后的容器元素我们称之为层叠上下文。

特性：
- 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。
- 每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。
- 层叠上下文未指定 z-index 时（css3创建的层叠上下文），其层叠等级与 z-index : 0 相同， 要比普通元素高。指定 z-index 时按照层叠规则来。

创建方式：
- 页面根元素
- z-index 值为数值的定位元素
> 1、z-index: auto 和 z-index: 0 在层叠等级上属于同一级。但是 z-index: 0 就是符合这一条“z-index 为数值”会使得元素升级为层叠上下文。
2、IE6，7 有个不合常理的地方，就是当元素的 z-index 为 auto 的时候，该元素也升级为创建层叠上下文。
- CSS3 属性。
  - z-index 值不为 auto 的 flex 项(父元素 display : flex | inline-flex )
  - 元素的 opacity 值不是 1
  - 元素的 transform 值不是 none
  - 元素的 filter 值不是 none
  - 其他

两个概念：
- 层叠顺序（ Stacking Order ），这个其实就是很字面的意思，它表示元素发生层叠时按照特定的顺序规则在 Z 轴上垂直显示顺序。
- 层叠等级（ Stacking Level ），这个很好理解了。层叠等级就是个描述元素层叠顺序的一个名词，它决定了同一个层叠上下文中元素在 Z 轴上的显示顺序。举个例子：A 元素与 B 元素重叠之后，A 元素在 B 元素上面。那么我们就可以直接说 A 元素的层叠等级大于 B 元素的层叠等级。

层叠规则：
- 当互相层叠的元素都是层叠上下文元素，即明确的有 z-index 值的时候（没有明确的 z-index 值的层叠上下文也就是 CSS3 创建的层叠上下文 z-index 值为0 ）直接比较 z-index 的值，值大的处在值小的元素的上方。
- 当元素处于同一层叠上下文内时可按照如下规则进行层叠判断。
![img.png](/img/层叠上下文.png)
- 当元素的层叠等级一致、层叠顺序也相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。

### flex布局
#### 基本概念
用flex布局的元素，称为flex container，它的所有子元素都是容器的flex item，容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。
主轴的开始位置（与边框的交叉点）叫做 main start ，结束位置叫做 main end ；交叉轴的开始位置叫做 cross start ，结束位置叫做 cross end 。

#### 属性
- flex container
  - flex direction
    - row
  - flex wrap
    - no wrap
  - flex-flow flex-direction 属性和 flex-wrap 属性的简写形式
  - justify-content
    - flex-start
  - align-items
    - stretch
  - align-content 前提是需要设置flex-wrap: wrap，否则不会有效
    - stretch

- flex item
  - order 数值越小，排列越靠前
    - 0
  - flex grow 
    - 0 不占用剩余的空间扩展宽度
  - flex shrink 容器空间不足时子项收缩比例
    - 1
  - flex basis 在主轴方向上的初始大小。优先级高于自身的宽度width
    - auto
  - flex flex-grow, flex-shrink, flex-basis 的缩写
    - 默认值为 0 1 auto 后两个属性可选。
  - align-self 垂直对齐方式。可覆盖 align-items 属性。
    - auto 继承自父元素 align-items

##### flex-shrink计算
收缩后的子项宽度是怎么样计算的呢？实际上有一个公式：
1. (200+300)所有子项的宽度的和 - (400)容器的宽度  = (100)
2. 第一个子项的宽度占比：2/5，第二个子项的宽度占比：3/5
3. 则第一个子项的的宽度为：200  - 2/5 * 100 = 160，第二个子项的宽度为：300  - 3/5 * 100 = 240

### 单行省略
```css
.ellipsis {
    width: xxpx;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
}
```

### 多行省略
```css
.ellipsis-2 {
    width: xxpx;
    text-overflow: ellipsis;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}
```

### 超长文本块的省略
```css
p {
    width: 200px;

    white-space: normal;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
}
p {
    width: 200px;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
}
/*上面两种搭配inline-block都可以*/
span {
    display: inline-block;
}
```

```html
<p>
    <span>文本块1</span>
    <span>文本块2</span>
    <span>文本块3</span>
</p>
```

### visibility: hidden, opacity: 0 和 display: none 的区别
- opacity: 0。元素不可见，但占据空间，可响应事件。
- visibility: hidden。元素不可见，占据空间，不可响应事件。
- display: none。元素隐藏，不占据空间，不可响应事件。

### 水平居中
- text-align: center。居中子元素为行内或行内块适用。
- margin: auto + width。居中元素需要设置具体宽度。
- width：fit-content。可以作用在居中元素或居中元素的父元素上。

### 垂直居中
- table-cell + vertical-align middle。
- line-height 与 height 同高 + 居中子元素inline-block，line-height initial。如果对子元素的大小没有要求，只需行高和高相同即可。
- 父元素伪元素inline-block，vertical middle，height 100% + 子元素inline-block。

### 水平垂直居中
- flex。flex中还有个方案是margin auto。
- grid。justify-self: center，align-self: center。margin auto也支持。
- 绝对定位+transform。
- 绝对定位+（calc、负margin）。需要知道居中元素宽高。
- 绝对定位+left、top等设置为0，margin auto。但会导致宽高100%。
- writing-mode。需要嵌套多一层元素。

```css
.out {
    writing-mode: vertical-lr;
    text-align: center;
}
.in {
    display: inline-block;
    width: 100%;
    height: auto;
    writing-mode: horizontal-tb;
    text-align: center;
}
.content {
    display: inline-block;
}
```
### 三栏布局
#### 左右固定，中间自适应
- 左右绝对定位定宽，中间用margin空出两边位置。缺点：当容器宽度小到一定程度，中间的元素会被遮挡。
- 左右定宽，左浮动左，右浮动右，中间margin空出两边位置。标签书写顺序要求左右中。容器宽度小到一定程度，中间元素被遮挡（看不到背景色），其子元素会和右栏元素重叠，当小于左右宽度之和，右栏换行。
- flex布局。左右定宽，中间flex: 1。
- 父table，子table-cell，左右定宽。容器宽度极小时横向滚动。
- 父grid, grid-template-columns: 100px auto 200px。容器宽度不够就横向滚动，但是超出的部分没有背景色。

#### 双飞翼布局、圣杯布局
双飞翼和圣杯布局左中右三列布局，渲染顺序中间列书写在前保证提前渲染，左右两列定宽，中间列自适应剩余宽度。

双飞翼：三个元素都是浮动，左列margin-left -100%（以父元素为基准），右列margin-left-自己宽度。中间宽度百分百，其子元素通过设置margin或padding空出两边。

圣杯：父元素padding空出两边，三个元素都是浮动，左列relative，left -自己宽度，margin-left -100%，右列right和margin-left -自己宽度，中间宽度百分百。

双飞翼兼容 IE6。

### 多列等高
多列等高，要求左右两列高度自适应且一样，分别设置不同背景色。

- 父overflow hidden，子都float，padding bottom9999，margin top -9999
- 父border-left空出左列宽度，左列float，margin-left -width。
- 障眼法。父背景渐变色，子都float left
```css
.p {
linear-gradient(90deg, #4caf50 0, #4caf50 20%, #99afe0 20%, #99afe0);
}
```
- flex，stretch
- grid。grid，grid-template-columns: 200px auto;
- 父table子都table-cell

### 单列固定，其余均分
首列宽度固定为200px，其余3列均分剩余宽度，每列间距10px
- grid-template-columns: 200px repeat(3, 1fr)，grid-column-gap: 10px。
- flex+calc
- float+calc
- absolute。分两个子元素，都absolute，左边固定宽度。右边清除浮动，前后伪元素table, 后伪元素clear：both。子元素是一个div，里面三个float left width 33.33%。

### 盒模型
盒模型包括content、padding、border和margin。

### box-sizing
不同的盒模型、width所指定的区域不同。box-sizing属性控制盒模型的解析模式。
1. content box。width设置的尺寸是content的尺寸。
2. border box。width设置的是包含border在内的尺寸。

### CSS选择器有哪些
1. id选择器
2. class选择器
3. 标签选择器
4. 后代选择器
5. 子元素选择器
6. 相邻选择器（h1 + p）
7. 通配符选择器（*）
8. 属性选择器（a[href="1"])
9. 伪类、伪元素选择器（a:hover, a::after）

### 选择器优先级
从小到大：继承、元素、类、id 和 !important。如果优先级相同，选择后出现的。

### 可继承的CSS属性
1. font-size
2. font-family
3. color

### 伪类
- :first-of-type 选择属于其父元素的首个元素
- :last-of-type 选择属于其父元素的最后元素
- :only-of-type 选择属于其父元素唯一的元素
- :only-child 选择属于其父元素的唯一子元素
- :nth-child(2) 选择属于其父元素的第二个子元素
- :enabled :disabled 表单控件的禁用状态
- :checked 单选框或复选框被选中

### 常见兼容性问题
1. IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。
2. Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。

### position属性比较
- static。默认值。出现在正常文档流中。忽略 top、left、right、bottom 和 z-index 声明。
- inherit。从父元素继承 position 值。
- relative。相对于元素原来的位置进行移动。占据原来的空间。移动元素后和其它元素重叠。
- fixed。相对于窗口固定。不占据空间，和其它元素重叠。
- absolute。相对于最近的定位元素移动，如果没有，相对于 html 标签。不占据空间。和其它元素重叠。
- sticky。元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为 fixed 定位。

### BFC块级格式上下文
BFC 规定了内部的 Block Box如何布局。
1. Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的垂直方向的margin会发生重叠。
2. BFC的区域不会与float box重叠。
3. BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。
4. 计算BFC的高度时，浮动元素也会参与计算。

满足下列条件之一就可触发BFC
1. 根元素，即html
2. float的值不为none（默认）
3. overflow的值不为visible（默认）
4. display的值为inline-block、table-cell、table-caption
5. position的值为absolute或fixed

相邻box的margin重叠规则：
- 都是正数时，重叠结果是两者较大的值
- 都是负数时，重叠结果是两者绝对值较大的值
- 一正一负时，重叠结果是两者相加的和

### 清除浮动的方式
1. 父级div定义height
2. 最后一个浮动元素后加空div标签，并添加样式clear:both。
3. 包含浮动元素的父标签添加样式overflow为hidden或auto。在 IE6 中还需要设置父元素宽高或 zoom: 1 来触发 hasLayout。
4. 父元素伪元素设置，前后伪元素 display table, 后伪元素clear both

### 设置元素浮动后，元素的display值是？
自动变成block

### 媒体查询
1. head 标签内 link 标签设置。

```html
<link rel="stylesheet" type="text/css" href="xxx.css" media="only screen and (max-device-width:480px)">
```
2. css

```css
@media only screen and (max-device-width:480px) {
}
```

### 在网页中的应该使用奇数还是偶数的字体？
使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。

### margin和padding适用场景
padding在border内，margin在外。padding有背景色，margin无。相邻盒子margin会重叠。

### padding、margin的百分比设定相对于哪个元素
相对于父元素的宽度

### 如何理解 line-height
行高是指两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。

### 怎么让 Chrome 支持小于12px 的文字？
transform scale

### 让页面里的字体变清晰，变细用 CSS 怎么做？
-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用-webkit-font-smoothing：antialiased是最佳的，灰度平滑。

### position:fixed; 在 Android 下无效怎么处理？
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/>
```

### 如果需要手动写动画，你认为最小时间间隔是多久，为什么？
多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。

### li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？
行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔。

解决方法：
1. li 代码写在一行
2. 浮动li
3. ul 设置字体大小0。或者letter-space: -3px

### style标签写在body后与body前有什么区别？
页面加载自上而下 当然是先加载样式。

写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，出现页面闪烁问题。

### CSS属性overflow属性定义溢出元素内容区的内容会如何处理?
- 参数是scroll时候，必会出现滚动条。
- 参数是auto时候，子元素内容大于父元素时出现滚动条。
- 参数是visible时候，溢出的内容出现在父元素之外。
- 参数是hidden时候，溢出隐藏。

### 如何解决a标点击后hover事件失效的问题
改变a标签css属性的排列顺序

只需要记住LoVe HAte原则就可以了：

`link(一般省略成a)→visited→hover→active`

## JS
## 常用八种继承方案
### 原型链继承
构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。

本质是用父类实例重写原型对象。

```
function SuperType() {
    this.property = true;
}

SuperType.prototype.getSuperValue = function() {
    return this.property;
}

function SubType() {
    this.subproperty = false;
}

// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype
SubType.prototype = new SuperType(); 

var instance = new SubType();
console.log(instance.getSuperValue()); // true
```

缺点：多个实例对引用类型的操作会被篡改。
```
function SuperType(){
  this.colors = ["red", "blue", "green"];
}
function SubType(){}

SubType.prototype = new SuperType();

var instance1 = new SubType();
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"

var instance2 = new SubType(); 
alert(instance2.colors); //"red,blue,green,black"
```

### 借用构造函数继承
使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）

```
function  SuperType(){
    this.color=["red","green","blue"];
}
function  SubType(){
    //核心代码
    SuperType.call(this);
}
var instance1 = new SubType();
instance1.color.push("black");
alert(instance1.color);//"red,green,blue,black"

var instance2 = new SubType();
alert(instance2.color);//"red,green,blue"
```

缺点：
- 只能继承父类的实例属性和方法，不能继承原型属性/方法
- 无法实现复用，每个子类都有父类实例函数的副本，影响性能

### 组合继承
组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。

```
function SuperType(name){
  this.name = name;
  this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
  alert(this.name);
};

function SubType(name, age){
  // 继承属性
  // 第二次调用SuperType()
  SuperType.call(this, name);
  this.age = age;
}

// 继承方法
// 构建原型链
// 第一次调用SuperType()
SubType.prototype = new SuperType(); 
// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType
SubType.prototype.constructor = SubType; 
SubType.prototype.sayAge = function(){
    alert(this.age);
};

var instance1 = new SubType("Nicholas", 29);
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //"Nicholas";
instance1.sayAge(); //29

var instance2 = new SubType("Greg", 27);
alert(instance2.colors); //"red,blue,green"
instance2.sayName(); //"Greg";
instance2.sayAge(); //27
```

缺点：
- 第一次调用SuperType()：给SubType.prototype写入两个属性name，color。
- 第二次调用SuperType()：给instance1写入两个属性name，color。

实例对象instance1上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。

### 原型式继承
利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。

```
function object(obj){
  function F(){}
  F.prototype = obj;
  return new F();
}

var person = {
  name: "Nicholas",
  friends: ["Shelby", "Court", "Van"]
};

var anotherPerson = object(person);
anotherPerson.name = "Greg";
```

缺点：
- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
- 无法传递参数

另外，ES5中存在Object.create()的方法，能够代替上面的object方法。

### 寄生组合式继承
结合借用构造函数传递参数和寄生模式实现继承。这是最成熟的方法，也是现在库实现的方法。

```
function inheritPrototype(subType, superType){
  var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本
  prototype.constructor = subType;                    // 增强对象，弥补因重写原型而失去的默认的constructor 属性
  subType.prototype = prototype;                      // 指定对象，将新创建的对象赋值给子类的原型
}

// 父类初始化实例属性和原型属性
function SuperType(name){
  this.name = name;
  this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
  alert(this.name);
};

// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）
function SubType(name, age){
  SuperType.call(this, name);
  this.age = age;
}

// 将父类原型指向子类
inheritPrototype(SubType, SuperType);

// 新增子类原型属性
SubType.prototype.sayAge = function(){
  alert(this.age);
}

var instance1 = new SubType("xyc", 23);
var instance2 = new SubType("lxy", 23);

instance1.colors.push("2"); // ["red", "blue", "green", "2"]
instance1.colors.push("3"); // ["red", "blue", "green", "3"]
```

### 混入方式继承多个对象
```
function MyClass() {
     SuperClass.call(this);
     OtherSuperClass.call(this);
}

// 继承一个类
MyClass.prototype = Object.create(SuperClass.prototype);
// 混合其它
Object.assign(MyClass.prototype, OtherSuperClass.prototype);
// 重新指定constructor
MyClass.prototype.constructor = MyClass;

MyClass.prototype.myMethod = function() {
     // do something
};
```
### class
```
class Rectangle {
    // constructor
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
    
    // Getter
    get area() {
        return this.calcArea()
    }
    
    // Method
    calcArea() {
        return this.height * this.width;
    }
}

const rectangle = new Rectangle(10, 20);
console.log(rectangle.area);
// 输出 200

-----------------------------------------------------------------
// 继承
class Square extends Rectangle {

  constructor(length) {
    super(length, length);
    
    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
    this.name = 'Square';
  }

  get area() {
    return this.height * this.width;
  }
}

const square = new Square(10);
console.log(square.area);
```

### null 和 undefined 区别
- null 表示空，此处不应该有值；而 undefined 表示未定义，变量声明了未赋值就是 undefined。
- 转换数字结果不同。Number(null)为0，undefined 为 NaN。
- null 是对象原型链终点

### 点击一个input依次触发的事件
`
'onmouseenter'
'onmousedown'
'onfocus'
'onclick'
`
### 闭包是什么
每个函数都有对应的词法环境，记录了变量和对外部词法环境引用。代码要访问变量时，会先搜索内部词法环境，找不到再搜索外部环境，直至全局词法环境。

闭包就是利用了这个特点，在函数内部保存了变量。闭包返回了嵌套函数，保留了对内部变量的引用，所以内部词法环境不会被删除。
### 设计一个不能操作 DOM 和调接口的环境
实现思路：

1）利用 iframe 创建沙箱，取出其中的原生浏览器全局对象作为沙箱的全局对象

2）设置一个黑名单，若访问黑名单中的变量，则直接报错，实现阻止/隔离的效果

3）在黑名单中添加 document 字段，来实现禁止开发者操作 DOM

4）在黑名单中添加 XMLHttpRequest、fetch、WebSocket 字段，实现禁用原生的方式调用接口

5）若访问当前全局对象中不存在的变量，则直接报错，实现禁用三方库调接口

6）最后还要拦截对 window 对象的访问，防止通过 window.document 来操作 DOM，避免沙箱逃逸

#### 实现
with对于沙箱的意义：可以实现所有变量均来自可靠或自主实现的上下文环境，而不会从全局的执行环境中取值，相当于做了一层拦截，实现隔离的效果

```javascript
// 沙箱全局代理对象类
class SandboxGlobalProxy {
  constructor(blacklist) {
    // 创建一个 iframe 标签，取出其中的原生浏览器全局对象作为沙箱的全局对象
    const iframe = document.createElement("iframe", { url: "about:blank" });
    iframe.style.display = "none";
    document.body.appendChild(iframe);

    // 获取当前HTMLIFrameElement的Window对象
    const sandboxGlobal = iframe.contentWindow;

    return new Proxy(sandboxGlobal, {
      // has 可以拦截 with 代码块中任意属性的访问
      has: (target, prop) => {

        // 黑名单中的变量禁止访问
        if (blacklist.includes(prop)) {
          throw new Error(`Can't use: ${prop}!`);
        }
        // sandboxGlobal对象上不存在的属性，直接报错，实现禁用三方库调接口
        if (!target.hasOwnProperty(prop)) {
          throw new Error(`Not find: ${prop}!`);
        }

        // 返回true，获取当前提供上下文对象中的变量；如果返回false，会继续向上层作用域链中查找
        return true;
      }
    });
  }
}

// 使用with关键字，来改变作用域
function withedYourCode(code) {
  code = "with(sandbox) {" + code + "}";
  return new Function("sandbox", code);
}

// 将指定的上下文对象，添加到待执行代码作用域的顶部
function makeSandbox(code, ctx) {
  withedYourCode(code).call(ctx, ctx);
}

// 待执行的代码code，获取document对象
const code = `console.log(document)`;

// 设置黑名单
const blacklist = ['window', 'document', 'XMLHttpRequest', 'fetch', 'WebSocket', 'Image'];

// 将globalProxy对象，添加到新环境作用域链的顶部
const globalProxy = new SandboxGlobalProxy(blacklist);

makeSandbox(code, globalProxy);
```

## 浏览器
### fetch 发送 2 次请求的原因
fetch 的 post 请求会先发送一次 options 请求，判断服务器是否支持，通过后才真正发送 post 请求。

### Cookie、sessionStorage、localStorage 的区别
共同点：都是保存在浏览器端，并且是同源的

不同点：
1. cookie 数据始终自动在同源的 http 请求中携带，其余两者不会。
2. cookie 有 path 的概念，可以限制 cookie 只属于某个路径下。
3. cookie 存储大小有限制，大约4K。
4. cookie 只和设置 cookie 时的过期时间有关。sessionStorage 在当前浏览器窗口关闭前有效。localStorage 始终有效。
5. cookie 和 localStorage 在所有同源窗口中共享。

### cookie 如何防范 XSS 攻击
XSS（跨站脚本攻击）是指攻击者在返回的 HTML 中嵌入 javascript 脚本。

在 HTTP 头部配上，set-cookie：

httponly - 这个属性可以防止 XSS,它会禁止 javascript 脚本来访问 cookie。

secure - 这个属性告诉浏览器仅在请求为 https 的时候发送 cookie。

### cookie 如何防范 csrf 攻击
CSRF：跨站请求伪造。需要用户已登录状态的cookie，在恶意网站中发起对目标网站的请求，浏览器发起请求时会携带对应域名的cookie。

防范措施：
- 服务器检测 origin header 和 Referer header
- 设置 cookie 的 same-site 属性。

### 说一下 web worker
在 HTML 页面中，脚本执行时，页面是不可响应的，脚本执行完成后，页面才恢复响应。web worker 是运行在后台的 js，不影响页面性能，运行结果通过 postMessage 回传到主线程。

### 说一下 iframe
iframe 元素会创建包含另一个文档的内联框架。

缺点：
- 会阻塞主页面的 onload 事件。
- 搜索引擎无法解析，不利于SEO。
- iframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。

### Doctype 作用
`<!DOCTYPE html>`作用是启用标准模式。而怪异模式是向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。

### 说一下RESTFUL
用 URL 定位资源，用 HTTP 描述操作。

### 浏览器的渲染
浏览器渲染大致分为五步，创建 DOM 树，创建 CSSOM(CSS Object Model)，创建 render 树，布局 layout 和绘制 Painting。
1. 分析 HTML 元素，构建一颗 DOM 树。
2. 分析 css 文件和元素内联样式，生成CSSOM。
3. 将 DOM 树和 CSSOM 关联起来，构建一颗 render 树。
4. 浏览器根据 render 树开始布局，确定每个节点的坐标。
5. 根据 render 树和节点坐标，绘制节点。

css 的解析是从右往左逆向解析的。

浏览器会阻塞页面渲染直到它接收和执行了所有的 CSS。CSS 是渲染阻塞是因为规则可以被覆盖，所以内容不能被渲染直到 CSSOM 的完成。完成后才能构建 render tree。

### 浏览器渲染优化方式
- 区分优先级，异步、延迟加载请求减少渲染时间
- 减少请求数量和体积
- 可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是 CPU 上绘制屏幕的一部分来提高渲染性能，从而释放主线程。但是它以内存管理为代价，不能过度使用。有一些特定的属性和元素可以实例化一个层，包括 <video> 和 <canvas>，任何 CSS 属性为 opacity 、3D transform、will-change 的元素。

### 回流（重排）和重绘
回流会触发重新绘制和重新排列。当改变元素的几何属性时就可能触发回流。重绘是重新绘制元素。当样式改变而几何属性没有改变时触发重绘。

例如页面初始化时图片大小未指定，从服务器获取到图片资源后将返回到布局阶段重新开始。
    
### 渲染进程下的线程
- GUI渲染线程：负责渲染浏览器界面，解析html,css,DOM Tree, render Tree ，layout,绘制等
- js引擎线程：解析js脚本，运行代码
- 事件触发线程：用于控制事件轮询，鼠标点击，AJAX异步请求等，对应任务会被添加到事件触发线程中，符合触发条件时，事件会被添加到任务队列等待JS引擎处理
- 定时器触发线程：定时器setInterval 和 setTimeout
- http请求线程：用于http请求

### v8的垃圾回收
将内存分为了 new space 和 old space。

#### new space
new space 分为 from space 和 to space。

回收算法：

首先v8引擎检测到 from space 空间快达到上线了，就会进行垃圾回收。

其次从根部开始遍历，不可达对象被标记，可达对象被复制到 to space。

最后清除 from space 数据，将 to space变成 from space，from space 变成 to space。

可达对象会被放到 old space中的 old object space。

#### old space
old space 分为以下几个区域：
- old object space。新生代晋升来的
- large object space。大对象存储区域。
- map space。存储对象映射关系。
- code space。存放编译后代码的地方。

回收算法：
从根部对象深度有限遍历标记，标记完成后等待垃圾回收器清理。清除了以后如果新生代对象被放到 old object space 时内存不足，就会触发 mark-compact，释放内存空间。

### click 在 ios 上有 300ms 延迟，原因及如何解决？
1. 禁用缩放

```
<meta name="viewport" content="width=device-width, user-scalable=no">
```
2. fastclick
检测到 touchend 事件后，立刻出发模拟 click 事件，并且把浏览器 300 毫秒之后真正触发的事件给阻断掉

## 网络
### node实现websocket
```
//ws.js
const { EventEmitter } = require('events');
const http = require('http');
const crypto = require('crypto');

function hashKey(key) {
  const sha1 = crypto.createHash('sha1');
  sha1.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
  return sha1.digest('base64');
}

function handleMask(maskBytes, data) {
  const payload = Buffer.alloc(data.length);
  for (let i = 0; i < data.length; i++) {
    payload[i] = maskBytes[i % 4] ^ data[i];
  }
  return payload;
}

const OPCODES = {
  CONTINUE: 0,
  TEXT: 1,
  BINARY: 2,
  CLOSE: 8,
  PING: 9,
  PONG: 10,
};

function encodeMessage(opcode, payload) {
  //payload.length < 126
  let bufferData = Buffer.alloc(payload.length + 2 + 0);;
  
  let byte1 = parseInt('10000000', 2) | opcode; // 设置 FIN 为 1
  let byte2 = payload.length;

  bufferData.writeUInt8(byte1, 0);
  bufferData.writeUInt8(byte2, 1);

  payload.copy(bufferData, 2);
  
  return bufferData;
}

class MyWebsocket extends EventEmitter {
  constructor(options) {
    super(options);

    const server = http.createServer();
    server.listen(options.port || 8080);

    server.on('upgrade', (req, socket) => {
      this.socket = socket;
      socket.setKeepAlive(true);

      const resHeaders = [
        'HTTP/1.1 101 Switching Protocols',
        'Upgrade: websocket',
        'Connection: Upgrade',
        'Sec-WebSocket-Accept: ' + hashKey(req.headers['sec-websocket-key']),
        '',
        ''
      ].join('\r\n');
      socket.write(resHeaders);

      socket.on('data', (data) => {
        this.processData(data);
        // console.log(data);
      });
      socket.on('close', (error) => {
          this.emit('close');
      });
    });
  }

  handleRealData(opcode, realDataBuffer) {
    switch (opcode) {
      case OPCODES.TEXT:
        this.emit('data', realDataBuffer.toString('utf8'));
        break;
      case OPCODES.BINARY:
        this.emit('data', realDataBuffer);
        break;
      default:
        this.emit('close');
        break;
    }
  }

  processData(bufferData) {
    // Reads an unsigned 8-bit integer from buf at the specified offset.
    const byte1 = bufferData.readUInt8(0);
    let opcode = byte1 & 0x0f; 
    // 第一位是 mask 标志位，后 7 位是 payload 长度。
    const byte2 = bufferData.readUInt8(1);
    const str2 = byte2.toString(2);
    const MASK = str2[0];

    let curByteIndex = 2;
    
    let payloadLength = parseInt(str2.substring(1), 2);
    if (payloadLength === 126) {
      payloadLength = bufferData.readUInt16BE(2);
      curByteIndex += 2;
    } else if (payloadLength === 127) {
      payloadLength = bufferData.readBigUInt64BE(2);
      curByteIndex += 8;
    }

    let realData = null;
    
    if (MASK) {
      const maskKey = bufferData.slice(curByteIndex, curByteIndex + 4);  
      curByteIndex += 4;
      const payloadData = bufferData.slice(curByteIndex, curByteIndex + payloadLength);
      realData = handleMask(maskKey, payloadData);
    } 
    
    this.handleRealData(opcode, realData);
  }

  send(data) {
    let opcode;
    let buffer;
    if (Buffer.isBuffer(data)) {
      opcode = OPCODES.BINARY;
      buffer = data;
    } else if (typeof data === 'string') {
      opcode = OPCODES.TEXT;
      buffer = Buffer.from(data, 'utf8');
    } else {
      console.error('暂不支持发送的数据类型')
    }
    this.doSend(opcode, buffer);
  }

  doSend(opcode, bufferDatafer) {
    this.socket.write(encodeMessage(opcode, bufferDatafer));
  }
}

module.exports = MyWebsocket;
```

```
const MyWebSocket = require('./ws');
const ws = new MyWebSocket({ port: 8080 });

ws.on('data', (data) => {
  console.log('receive data:' + data);
  setInterval(() => {
    ws.send(data + ' ' + Date.now());
  }, 2000)
});

ws.on('close', (code, reason) => {
  console.log('close:', code, reason);
});
```
```
<!DOCTYPE HTML>
<html>
<body>
    <script>
        const ws = new WebSocket("ws://localhost:8080");

        ws.onopen = function () {
            ws.send("发送数据");
            setTimeout(() => {
                ws.send("发送数据2");
            }, 3000)
        };

        ws.onmessage = function (evt) {
            console.log(evt)
        };

        ws.onclose = function () {
        };
    </script>
</body>

</html>
```

## 资料
[CSS 拷问：水平垂直居中方法你会几种？](https://liuyib.github.io/2020/04/07/css-h-and-v-center/)

[CSS灵感](https://csscoco.com/inspiration/)

[面试官：请设计一个不能操作 DOM 和调接口的环境](https://juejin.cn/post/7157570429928865828)

[用nodejs手写websocket](https://mp.weixin.qq.com/s/EWE6vIvwWDJ_A6SqikV6Tg)

[chrome浏览器渲染进程工作流程](https://juejin.cn/post/6962087948112101383)

