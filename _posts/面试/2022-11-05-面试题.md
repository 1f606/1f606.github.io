---
layout:     post
title:      面试题
subtitle:   
date:       2022-11-05
author:     
header-img: 
catalog: true
tags:
    - 面试
---
# 面试题
## vue
### 对vue的理解
Vue是一个创建单页应用的框架。

核心特性：
1. 数据驱动MVVM。

- Model：模型层。负责处理业务逻辑，泛指后端进行的各种业务逻辑处理和数据操控。
- View：视图层：负责将数据模型转化为UI展示出来。
- ViewModel：视图模型层，通过双向绑定用来连接Model和View。

Vue 框架就是充当了 MVVM 开发模式中的 ViewModel 层，负责 View 和 Model 之间通信的桥梁。开发时只需要关心 View 层的 HTML 代码和 Model 层的 JavaScript 逻辑就可以了。

> MVC
> 
> Model：数据模型，用来存储数据
> 
> View：视图界面，用来展示UI界面和响应用户交互
> 
> Controller：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互

框架的双向绑定让开发者不再需要频繁操作DOM，只需处理好viewModel，视图就会更新，实现数据驱动开发。

ViewModel它的主要职责就是：
- 数据变化后更新视图
- 视图变化后更新数据

当然，它还有两个主要部分组成
- 监听器（Observer）：对所有数据的属性进行监听
- 解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数

2. 组件化

组件化就是把视图和非视图的各种逻辑均抽象为一个统一的概念来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件。

优点是降低了系统耦合度，方便调试和提高了可维护性。
3. 指令系统

指令是带有 v- 前缀的特殊属性，当对应的表达式发生变化，会作用到DOM上。

### 什么是SPA
SPA就是单页应用。通过动态重写当前页面与用户交互，避免了页面之间切换而频繁刷新。

### SPA和MPA区别
MPA中每个页面都是独立的，访问另外一个页面时需要重新加载CSS、HTML和JS。切换页面会整页刷新，对SEO友好。

### 实现SPA
#### hash模式
```javascript
class Router {
  constructor () {
    this.routes = {};
    this.currentUrl = '';
    window.addEventListener('load', this.refresh, false);
    window.addEventListener('hashchange', this.refresh, false);
  }
  route (path, callback) {
    this.routes[path] = callback;
  }
  push (path) {
    this.routes[path] && this.routes[path]();
  }
  refresh () {
    const url = window.location.hash.slice(1);
    this.routes[url] && this.routes[url]();
  }
}
```
#### history模式

history.pushState 浏览器历史纪录添加记录

history.replaceState修改浏览器历史纪录中当前纪录

history.popState 当 history 发生变化时触发

通过history.pushState方法改变地址栏。仅改变url和增加到历史记录中，不会向服务器发起请求。

改变会触发popstate事件。调用pushState和replaceState不会触发这个事件。只有点击浏览器的前进，后退，调用history.back和history.forward的时候才会触发。

#### Vue中hash模式和history模式的区别
- 在显示上，hash模式的URL中会夹杂着#号，而history没有。
- 实现方式不同。hash模式是依靠hashchange事件，而history模式是主要是依靠的HTML5 history中新增的两个方法pushState和replaceState。
- 当真正需要通过URL向后端发送HTTP请求的时候，比如常见的用户手动输入URL后回车，或者是刷新(重启)浏览器，这时候history模式需要后端的支持。
因为history模式下，前端的URL必须和实际向后端发送请求的URL一致，例如有一个URL是带有路径path的(例如www.lindaidai.wang/blogs/id)，
如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面。

### 如何给SPA做SEO优化
1. 服务端渲染，如nuxt
2. 静态化

目前主流的静态化主要有两种：
- 一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中
- 另外一种是通过WEB服务器的 URL Rewrite的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果

3. 使用Phantomjs针对爬虫处理

### SPA首屏加载速度慢
1. 首屏时间计算：new Date.getTime() - performance.timing.navigationStart（在body标签后计算）
2. 白屏时间计算：在`<head>`标签前面加一个`<script>`标签，里面加入上面相同代码。

#### 加载慢的原因
- 网络延时
- 资源体积
- 渲染堵塞

#### 解决方法
减小入口文件体积。路由懒加载，UI框架按需加载，使用在线字体和雪碧图

组件重复打包，webpack config minChunks。

使用SSR

网络优化策略

减少 HTTP 请求数，合并 JS、CSS,合理内嵌 CSS、JS

设置 HTTP 缓存，Cache-Control，Last-Modified，Etag等响应头。(强制缓存、对比缓存)

避免重定向，重定向会降低响应速度 (301,302)

使用 dns-prefetch,进行 DNS 预解析

采用域名分片技术，将资源放到不同的域名下。解决同一个域名最多处理 6 个 TCP 链接问题

采用 CDN 加速加快访问速度。(指派最近、高度可用)

gzip 压缩优化 对传输资源进行体积压缩 (html,js,css)

加载数据优先级 : preload（预先请求当前页面需要的资源） prefetch（将来页面中使用的资源）将数据缓存到 HTTP 缓存中

避免重排重绘的方法

脱离文档流

渲染时给图片增加固定宽高

尽量使用 css3 动画

可以使用 will-change 提取到单独的图层中

CSS优化

减少伪类选择器、减少样式层数、减少使用通配符

避免使用 CSS 表达式，CSS 表达式会频繁求值， 当滚动页面，或者移动鼠标时都会重新计算 (IE6,7)

删除空行、注释、减少无意义的单位、css 进行压缩

使用外链 css,可以对 CSS 进行缓存

添加媒体字段，只加载有效的 css 文件

减少 @import 使用，由于 @import 采用的是串行加载

JS优化

通过 async、defer 异步加载文件

减少 DOM 操作，缓存访问过的元素

操作不直接应用到 DOM 上，而应用到虚拟 DOM 上。最后一次性的应用到 DOM 上

requestAnimationFrame、requestIdleCallback

尽量避免使用 eval, 消耗时间久

使用事件委托，减少事件绑定个数。

尽量使用 canvas 动画、CSS 动画

当需要设置的样式很多时设置 className 而不是直接操作 style

虚拟滚动

### 对于 async、defer 的理解
由于 html 的解析是由上到下的，所以当遇到 script 标签时，就会停止解析，下载 js 然后执行，执行完毕后继续解析，这就导致我们需要把 script 标签放到 html 的最下方，等到 dom 解析完毕，再去执行 js，才能实现 hmtl 的解析不被 js 阻塞。

为了解决 script 标签必须放到底部的问题，那么可以对 script 标签添加 async、defer 属性

defer

当浏览器解析遇到带有 defer 标签的 script 时，浏览器继续往下面解析页面，且会并行下载 script 标签的外部 js 文件

解析完 HTML 页面，再执行刚下载的 js 脚本

defer 脚本会在文档渲染完毕后 DOMContentLoaded 事件调用前执行，即刚刚解析完，且可保证执行顺序就是他们在页面上的先后顺序

DOMContentLoaded 事件的触发时机为初始 HTML 被构建完成时，此时 CSS、图片等资源不需要加载完，但我们的脚本要执行完。

如果多个 script 设置了 defer 属性，这几个 script 的执行顺序和声明顺序相同，即最前面的脚本先执行。

内置 js 代码的 script 标签，以及动态生成的 script 标签，defer 属性不生效

async

当浏览器解析遇到带有 async 属性的 script 标签，会继续往下解析，并且同时另开进程下载脚本

脚本下载完毕，浏览器停止解析，开始执行脚本，执行完毕后继续往下解析

设置 async 后，脚本一旦被下载好了就会执行，不管什么时机，所以执行顺序就是谁先下载好谁先执行

虽然 async 的加载是异步执行的，由于 async 是只要加载好就执行，所以 async 的执行阶段会打断页面解析

### vue中组件和插件的区别
组件是用来构成应用的业务模块，插件是增强技术栈的功能模块

### vue中的通信方式
- 通过 props 传递
- 通过 $emit 触发自定义事件
- 使用 ref
- EventBus
- $parent 或$root
- attrs 与 listeners
- Provide 与 Inject

### vue的优缺点
优点：
- 响应式。不用操作 DOM，把精力更多放在业务逻辑。
- 组件化。可复用部分可以抽离做成组件，提高开发效率，项目可维护性更高。
- 虚拟DOM。性能提升

缺点：
- 不利于SEO
- 导航不可用，需要自己实现前进后退。
- 初次加载耗时较长

### 虚拟DOM
虚拟DOM本质就是用一个原生的JavaScript对象去描述一个DOM节点。是对真实DOM的一层抽象。

由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题，因此我们需要这一层抽象，在patch过程中尽可能地一次性将差异更新到DOM中，这样保证了DOM不会出现性能很差的情况。

另外还有很重要的一点，为了更好的跨平台，比如Node.js就没有DOM,如果想实现SSR(服务端渲染),那么一个方式就是借助Virtual DOM,因为Virtual DOM本身是JavaScript对象。

### 指令

### 响应式原理

#### 数组的处理

### key, diff算法

## css
### inline, inline block 和 block 区别
- block 前后都有换行符，能设置宽高和内外边距。
- inlin-block，前后无换行符，能设置宽高和内外边距。
- inline，前后无换行符，无法设置宽高，margin水平方向有效，padding水平垂直都有效。

### link 标签和 @import 的区别
- 页面被加载时，link 标签会同时被加载，而@import 引用的 css 会等到页面加载结束后加载。
- @import 在 IE5 以上才支持，link 标签没有兼容性问题。

### 层叠上下文
当 z-index 为数值并且生效的时候，容器会发生一种变化，会使得容器内的子组件无法穿过容器本身，并且子组件的层级由父组件决定。这种变化后的容器元素我们称之为层叠上下文。

特性：
- 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。
- 每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。
- 层叠上下文未指定 z-index 时（css3创建的层叠上下文），其层叠等级与 z-index : 0 相同， 要比普通元素高。指定 z-index 时按照层叠规则来。

创建方式：
- 页面根元素
- z-index 值为数值的定位元素
> 1、z-index: auto 和 z-index: 0 在层叠等级上属于同一级。但是 z-index: 0 就是符合这一条“z-index 为数值”会使得元素升级为层叠上下文。
> 2、IE6，7 有个不合常理的地方，就是当元素的 z-index 为 auto 的时候，该元素也升级为创建层叠上下文。
- CSS3 属性。
  - z-index 值不为 auto 的 flex 项(父元素 display : flex 或 inline-flex )
  - 元素的 opacity 值不是 1
  - 元素的 transform 值不是 none
  - 元素的 filter 值不是 none
  - 其他

两个概念：
- 层叠顺序（ Stacking Order ），这个其实就是很字面的意思，它表示元素发生层叠时按照特定的顺序规则在 Z 轴上垂直显示顺序。
- 层叠等级（ Stacking Level ），这个很好理解了。层叠等级就是个描述元素层叠顺序的一个名词，它决定了同一个层叠上下文中元素在 Z 轴上的显示顺序。举个例子：A 元素与 B 元素重叠之后，A 元素在 B 元素上面。那么我们就可以直接说 A 元素的层叠等级大于 B 元素的层叠等级。

层叠规则：
- 当互相层叠的元素都是层叠上下文元素，即明确的有 z-index 值的时候（没有明确的 z-index 值的层叠上下文也就是 CSS3 创建的层叠上下文 z-index 值为0 ）直接比较 z-index 的值，值大的处在值小的元素的上方。
- 当元素处于同一层叠上下文内时可按照如下规则进行层叠判断。
![img.png](/img/层叠上下文.png)
- 当元素的层叠等级一致、层叠顺序也相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。

### flex布局
#### 基本概念
用flex布局的元素，称为flex container，它的所有子元素都是容器的flex item，容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。
主轴的开始位置（与边框的交叉点）叫做 main start ，结束位置叫做 main end ；交叉轴的开始位置叫做 cross start ，结束位置叫做 cross end 。

#### 属性
- flex container
  - flex direction
    - row
  - flex wrap
    - no wrap
  - flex-flow flex-direction 属性和 flex-wrap 属性的简写形式
  - justify-content
    - flex-start
  - align-items
    - stretch
  - align-content 前提是需要设置flex-wrap: wrap，否则不会有效
    - stretch

- flex item
  - order 数值越小，排列越靠前
    - 0
  - flex grow 
    - 0 不占用剩余的空间扩展宽度
  - flex shrink 容器空间不足时子项收缩比例
    - 1
  - flex basis 在主轴方向上的初始大小。优先级高于自身的宽度width
    - auto
  - flex flex-grow, flex-shrink, flex-basis 的缩写
    - 默认值为 0 1 auto 后两个属性可选。
  - align-self 垂直对齐方式。可覆盖 align-items 属性。
    - auto 继承自父元素 align-items

##### flex-shrink计算
收缩后的子项宽度是怎么样计算的呢？实际上有一个公式：
1. (200+300)所有子项的宽度的和 - (400)容器的宽度  = (100)
2. 第一个子项的宽度占比：2/5，第二个子项的宽度占比：3/5
3. 则第一个子项的的宽度为：200  - 2/5 * 100 = 160，第二个子项的宽度为：300  - 3/5 * 100 = 240

### 单行省略
```css
.ellipsis {
    width: xxpx;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
}
```

### 多行省略
```css
.ellipsis-2 {
    width: xxpx;
    text-overflow: ellipsis;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    word-break: break-all;
}
```

https://libin1991.github.io/2019/01/02/JS%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%A1%8C%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E6%80%9D%E8%B7%AF/

### 超长文本块的省略
```css
p {
    width: 200px;

    white-space: normal;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
}
p {
    width: 200px;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
}
/*上面两种搭配inline-block都可以*/
span {
    display: inline-block;
}
```

```html
<p>
    <span>文本块1</span>
    <span>文本块2</span>
    <span>文本块3</span>
</p>
```

### visibility: hidden, opacity: 0 和 display: none 的区别
- opacity: 0。元素不可见，但占据空间，可响应事件。
- visibility: hidden。元素不可见，占据空间，不可响应事件。
- display: none。元素隐藏，不占据空间，不可响应事件。

### 单行居中、多行居中
单行居中：父元素设置行高即可，不过如果设置了高度，行高就必须和高度一致。

多行居中：父元素设置行高，子元素设置为行内快，单独设置和父元素不同的行高。

父元素设置高度，子元素设置行内块，vertical-align：middle。同时给父元素的伪元素设置行内块和垂直居中，宽度0高度百分百。

### 水平居中
- text-align: center。居中子元素为行内或行内块适用。
- margin: auto + width。居中元素需要设置具体宽度。
- width：fit-content + margin: auto。可以作用在居中元素或居中元素的父元素上。

### 垂直居中
- table-cell + vertical-align middle。
- line-height 与 height 同高 + 居中子元素inline-block，line-height initial。如果对子元素的大小没有要求，只需行高和高相同即可。
- 父元素伪元素inline-block，vertical middle，height 100% + 子元素inline-block。

### 水平垂直居中
- flex。flex中还有个方案是margin auto。
- grid。justify-self: center，align-self: center。margin auto也支持。
- 绝对定位+transform。
- 绝对定位+（calc、负margin）。需要知道居中元素宽高。
- 绝对定位+left、top等设置为0，margin auto。但会导致宽高100%。
- writing-mode。需要嵌套多一层元素。

```css
.out {
    writing-mode: vertical-lr;
    text-align: center;
}
.in {
    display: inline-block;
    width: 100%;
    height: auto;
    writing-mode: horizontal-tb;
    text-align: center;
}
.content {
    display: inline-block;
}
```
### 三栏布局
#### 左右固定，中间自适应
- 左右绝对定位定宽，中间用margin空出两边位置。缺点：当容器宽度小到一定程度，中间的元素会被遮挡。
- 左右定宽，左浮动左，右浮动右，中间margin空出两边位置。标签书写顺序要求左右中。容器宽度小到一定程度，中间元素被遮挡（看不到背景色），其子元素会和右栏元素重叠，当小于左右宽度之和，右栏换行。
- flex布局。左右定宽，中间flex: 1。
- 父table，子table-cell，左右定宽。容器宽度极小时横向滚动。
- 父grid, grid-template-columns: 100px auto 200px。容器宽度不够就横向滚动，但是超出的部分没有背景色。

#### 双飞翼布局、圣杯布局
双飞翼和圣杯布局左中右三列布局，渲染顺序中间列书写在前保证提前渲染，左右两列定宽，中间列自适应剩余宽度。

双飞翼：三个元素都是浮动，左列margin-left -100%（以父元素为基准），右列margin-left-自己宽度。中间宽度百分百，其子元素通过设置margin或padding空出两边。

圣杯：父元素padding空出两边，三个元素都是浮动，左列relative，left -自己宽度，margin-left -100%，右列right和margin-left -自己宽度，中间宽度百分百。

双飞翼兼容 IE6。

### 多列等高
多列等高，要求左右两列高度自适应且一样，分别设置不同背景色。

- 父overflow hidden，子都float，padding bottom9999，margin top -9999
- 父border-left空出左列宽度，左列float，margin-left -width。
- 障眼法。父背景渐变色，子都float left
```css
.p {
linear-gradient(90deg, #4caf50 0, #4caf50 20%, #99afe0 20%, #99afe0);
}
```
- flex，stretch
- grid。grid，grid-template-columns: 200px auto;
- 父table子都table-cell

### 单列固定，其余均分
首列宽度固定为200px，其余3列均分剩余宽度，每列间距10px
- grid-template-columns: 200px repeat(3, 1fr)，grid-column-gap: 10px。
- flex+calc
- float+calc
- absolute。分两个子元素，都absolute，左边固定宽度。右边清除浮动，前后伪元素table, 后伪元素clear：both。子元素是一个div，里面三个float left width 33.33%。

### 盒模型
盒模型包括content、padding、border和margin。

### box-sizing
不同的盒模型、width所指定的区域不同。box-sizing属性控制盒模型的解析模式。
1. content box。width设置的尺寸是content的尺寸。
2. border box。width设置的是包含border在内的尺寸。

### CSS选择器有哪些
1. id选择器
2. class选择器
3. 标签选择器
4. 后代选择器
5. 子元素选择器
6. 相邻选择器（h1 + p）
7. 通配符选择器（*）
8. 属性选择器（a[href="1"])
9. 伪类、伪元素选择器（a:hover, a::after）

### 选择器优先级
从小到大：继承、元素、类、id 和 !important。如果优先级相同，选择后出现的。

### 可继承的CSS属性
1. font-size
2. font-family
3. color

### 伪类
- :first-of-type 选择属于其父元素的首个元素
- :last-of-type 选择属于其父元素的最后元素
- :only-of-type 选择属于其父元素唯一的元素
- :only-child 选择属于其父元素的唯一子元素
- :nth-child(2) 选择属于其父元素的第二个子元素
- :enabled :disabled 表单控件的禁用状态
- :checked 单选框或复选框被选中

### 常见兼容性问题
1. IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。
2. Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。

### position属性比较
- static。默认值。出现在正常文档流中。忽略 top、left、right、bottom 和 z-index 声明。
- inherit。从父元素继承 position 值。
- relative。相对于元素原来的位置进行移动。占据原来的空间。移动元素后和其它元素重叠。
- fixed。相对于窗口固定。不占据空间，和其它元素重叠。
- absolute。相对于最近的定位元素移动，如果没有，相对于 html 标签。不占据空间。和其它元素重叠。
- sticky。元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为 fixed 定位。

### BFC块级格式上下文
BFC 规定了内部的 Block Box如何布局。
1. Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的垂直方向的margin会发生重叠。
2. BFC的区域不会与float box重叠。
3. BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。
4. 计算BFC的高度时，浮动元素也会参与计算。

满足下列条件之一就可触发BFC
1. 根元素，即html
2. float的值不为none（默认）
3. overflow的值不为visible（默认）
4. display的值为inline-block、table-cell、table-caption
5. position的值为absolute或fixed

相邻box的margin重叠规则：
- 都是正数时，重叠结果是两者较大的值
- 都是负数时，重叠结果是两者绝对值较大的值
- 一正一负时，重叠结果是两者相加的和

### 清除浮动的方式
1. 最后一个浮动元素后加空div标签，并添加样式clear:both。
2. 包含浮动元素的父标签添加样式overflow为hidden或auto。在 IE6 中还需要设置父元素宽高或 zoom: 1 来触发 hasLayout。
3. 父元素伪元素设置，前后伪元素 display table, 后伪元素clear both

### 设置元素浮动后，元素的display值是？
自动变成block

### 媒体查询
1. head 标签内 link 标签设置。

```html
<link rel="stylesheet" type="text/css" href="xxx.css" media="only screen and (max-device-width:480px)">
```
2. css

```css
@media only screen and (max-device-width:480px) {
}
```

### 在网页中的应该使用奇数还是偶数的字体？
使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。

### margin和padding适用场景
padding在border内，margin在外。padding有背景色，margin无。相邻盒子margin会重叠。

### padding、margin的百分比设定相对于哪个元素
相对于父元素的宽度

### 如何理解 line-height
行高是指两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。

### 怎么让 Chrome 支持小于12px 的文字？
transform scale

### 让页面里的字体变清晰，变细用 CSS 怎么做？
-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用-webkit-font-smoothing：antialiased是最佳的，灰度平滑。

### position:fixed; 在 Android 下无效怎么处理？
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/>
```

### 如果需要手动写动画，你认为最小时间间隔是多久，为什么？
多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。

### li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？
行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔。

解决方法：
1. li 代码写在一行
2. 浮动li
3. ul 设置字体大小0。或者letter-space: -3px

### style标签写在body后与body前有什么区别？
页面加载自上而下 当然是先加载样式。

写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，出现页面闪烁问题。

### CSS属性overflow属性定义溢出元素内容区的内容会如何处理?
- 参数是scroll时候，必会出现滚动条。
- 参数是auto时候，子元素内容大于父元素时出现滚动条。
- 参数是visible时候，溢出的内容出现在父元素之外。
- 参数是hidden时候，溢出隐藏。

### 如何解决a标点击后hover事件失效的问题
改变a标签css属性的排列顺序

只需要记住LoVe HAte原则就可以了：

`link(一般省略成a)→visited→hover→active`

## JS
### CommonJS 和 ES6 模块的区别
- CommonJS 是运行时加载，加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。ES6 Module 是编译时输出接口。它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
- CommonJS 输出的是值的拷贝，ES6 Module 输出的是值的引用。
- CommonJS 导入的模块路径可以是一个表达式，用的是 `require` 方法，而 ES Module 只能是字符串
- CommonJS 中 `this` 指向当前模块，ES6 Module `this` 指向 `undefined`
- CommonJS 中有一些顶层变量 arguments、require、module、exports、__filename、__dirname

### typeof 和 instanceof 区别
- typeof：基本数据类型都能正常显示，除了null。引用类型只有函数正常显示，其余为 'object'。
- instanceof：用于检测某个构造函数的原型对象在不在某个对象的原型链上。

### requestAnimationFrame
大多数电脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60 次。因此，最平滑动画的最佳循环间隔是 1000ms/60，约等于 16.6ms。

RAF 采用的是系统时间间隔，不会因为前面的任务，不会影响 RAF，但是如果前面的任务多的话，会响应 setTimeout 和 setInterval 真正运行时的时间间隔。

与 setTimeout 和 setInterval 不同，requestAnimationFrame 不需要设置时间间隔。

特点：
- requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。
- 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量。
- requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。

### == 和 === 以及 Object.is 的区别

#### 严格相等
两个被比较的值在比较前都不进行隐式转换。

* 如果两个被比较的值具有不同的类型，这两个值是不相等的。
* 如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值相等。
* 如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是相等的。

#### Object.is
Object.is() 和 === 之间的唯一区别在于它们处理带符号的 0 和 NaN 值的时候。

=== 运算符（和 == 运算符）将数值 -0 和 +0 视为相等，将 NaN 视为不相等。

Object.is()将0和+0视为相等，-0和其余两者不相等。将 NaN 视为相等。

#### ==
1. 如果操作数具有相同的类型，则按以下方式进行比较：

* Object：仅当两个操作数引用相同的对象时，才返回 true。
* String：仅当两个操作数具有相同的字符并且顺序相同，才返回 true。
* Number：仅当两个操作数具有相同的值时，才返回 true。+0 和 -0 被视为相同的值。如果任一操作数为 NaN，则返回 false；因此 NaN 永远不等于 NaN。
* Boolean：仅当操作数都是 true 或 false 时，才返回 true。
* BigInt：仅当两个操作数具有相同的值时，才返回 true。
* Symbol：仅当两个操作数引用相同的 symbol 时，才返回 true。

2. 如果操作数之一为 null 或 undefined，则另一个操作数必须为 null 或 undefined 才返回 true。否则返回 false。
3. 如果操作数之一是对象，而另一个是原始值，则将对象转换为原始值。

> 对象转换为原始值是通过调用@@toPrimitive方法，里面调用了valueOf和toString方法。
> 优先从valueOf方法中获取原始值，如果不是原始值就调用toString，两者都没返回原始值，就会抛出类型错误。
> Symbol重写了[@@toPrimitive]()方法，返回了symbol

4. 在这一步骤中，两个操作数都被转换为原始值（String、Number、Boolean、Symbol 和 BigInt 之一）。剩余的转换将分情况完成。

> 如果它们是相同类型的，则使用步骤 1 进行比较。
> 如果操作数中有一个是 Symbol，但另一个不是，则返回 false。
> 如果操作数之一是 Boolean，而另一个不是，则将 Boolean 转换为 Number：true 转换为 1，false 转换为 0。然后再次对两个操作数进行宽松比较。
> Number 和 String：将 String 转换为 Number。转换失败会得到 NaN，这将确保相等性为 false。

> 将 String 转换为 Number 的步骤
> 
> Strings are converted by parsing them as if they contain a number literal. Parsing failure results in NaN. There are 
some minor differences compared to an actual number literal:
> 
> Leading and trailing whitespace/line terminators are ignored.
> 
> A leading 0 digit does not cause the number to become an octal literal (or get rejected in strict mode).
> 
> \+ and \- are allowed at the start of the string to indicate its sign. (In actual code, they "look like" part of the literal, but are actually separate unary operators.) However, the sign can only appear once, and must not be followed by whitespace.
> 
> `Infinity` and `-Infinity` are recognized as literals. In actual code, they are global variables.
> 
> Empty or whitespace-only strings are converted to 0.
> 
> Numeric separators are not allowed.

5. Number 转 BigInt：按照其数值进行比较。如果 Number 是 ±Infinity 或 NaN，返回 false。
6. String 转 BigInt: 使用与 BigInt() 构造函数相同的算法将字符串转换为 BigInt。如果转换失败，则返回 false。

### 常用八种继承方案
#### 原型链继承
构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。

本质是用父类实例重写原型对象。

```
function SuperType() {
    this.property = true;
}

SuperType.prototype.getSuperValue = function() {
    return this.property;
}

function SubType() {
    this.subproperty = false;
}

// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype
SubType.prototype = new SuperType(); 

var instance = new SubType();
console.log(instance.getSuperValue()); // true
```

缺点：多个实例对引用类型的操作会被篡改。
```
function SuperType(){
  this.colors = ["red", "blue", "green"];
}
function SubType(){}

SubType.prototype = new SuperType();

var instance1 = new SubType();
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"

var instance2 = new SubType(); 
alert(instance2.colors); //"red,blue,green,black"
```

#### 借用构造函数继承
使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）

```
function  SuperType(){
    this.color=["red","green","blue"];
}
function  SubType(){
    //核心代码
    SuperType.call(this);
}
var instance1 = new SubType();
instance1.color.push("black");
alert(instance1.color);//"red,green,blue,black"

var instance2 = new SubType();
alert(instance2.color);//"red,green,blue"
```

缺点：
- 只能继承父类的实例属性和方法，不能继承原型属性/方法
- 无法实现复用，每个子类都有父类实例函数的副本，影响性能

#### 组合继承
组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。

```
function SuperType(name){
  this.name = name;
  this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
  alert(this.name);
};

function SubType(name, age){
  // 继承属性
  // 第二次调用SuperType()
  SuperType.call(this, name);
  this.age = age;
}

// 继承方法
// 构建原型链
// 第一次调用SuperType()
SubType.prototype = new SuperType(); 
// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType
SubType.prototype.constructor = SubType; 
SubType.prototype.sayAge = function(){
    alert(this.age);
};

var instance1 = new SubType("Nicholas", 29);
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //"Nicholas";
instance1.sayAge(); //29

var instance2 = new SubType("Greg", 27);
alert(instance2.colors); //"red,blue,green"
instance2.sayName(); //"Greg";
instance2.sayAge(); //27
```

缺点：
- 第一次调用SuperType()：给SubType.prototype写入两个属性name，color。
- 第二次调用SuperType()：给instance1写入两个属性name，color。

实例对象instance1上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。

#### 原型式继承
利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。

```
function object(obj){
  function F(){}
  F.prototype = obj;
  return new F();
}

var person = {
  name: "Nicholas",
  friends: ["Shelby", "Court", "Van"]
};

var anotherPerson = object(person);
anotherPerson.name = "Greg";
```

缺点：
- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
- 无法传递参数

另外，ES5中存在Object.create()的方法，能够代替上面的object方法。

#### 寄生组合式继承
结合借用构造函数传递参数和寄生模式实现继承。这是最成熟的方法，也是现在库实现的方法。

```
function inheritPrototype(subType, superType){
  var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本
  prototype.constructor = subType;                    // 增强对象，弥补因重写原型而失去的默认的constructor 属性
  subType.prototype = prototype;                      // 指定对象，将新创建的对象赋值给子类的原型
}

// 父类初始化实例属性和原型属性
function SuperType(name){
  this.name = name;
  this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
  alert(this.name);
};

// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）
function SubType(name, age){
  SuperType.call(this, name);
  this.age = age;
}

// 将父类原型指向子类
inheritPrototype(SubType, SuperType);

// 新增子类原型属性
SubType.prototype.sayAge = function(){
  alert(this.age);
}

var instance1 = new SubType("xyc", 23);
var instance2 = new SubType("lxy", 23);

instance1.colors.push("2"); // ["red", "blue", "green", "2"]
instance1.colors.push("3"); // ["red", "blue", "green", "3"]
```

#### 混入方式继承多个对象
```
function MyClass() {
     SuperClass.call(this);
     OtherSuperClass.call(this);
}

// 继承一个类
MyClass.prototype = Object.create(SuperClass.prototype);
// 混合其它
Object.assign(MyClass.prototype, OtherSuperClass.prototype);
// 重新指定constructor
MyClass.prototype.constructor = MyClass;

MyClass.prototype.myMethod = function() {
     // do something
};
```

#### class
```
class Rectangle {
    // constructor
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
    
    // Getter
    get area() {
        return this.calcArea()
    }
    
    // Method
    calcArea() {
        return this.height * this.width;
    }
}

const rectangle = new Rectangle(10, 20);
console.log(rectangle.area);
// 输出 200

-----------------------------------------------------------------
// 继承
class Square extends Rectangle {

  constructor(length) {
    super(length, length);
    
    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
    this.name = 'Square';
  }

  get area() {
    return this.height * this.width;
  }
}

const square = new Square(10);
console.log(square.area);
```

### 数组去重
1. Set
2. 双层for循环
3. indexOf, includes
4. sort + for循环
5. filter + indexOf
6. Map
7. reduce + includes

### Promise
Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。由于它的then方法和catch、finally方法会返回一个新的Promise所以可以允许我们链式调用，解决了传统的回调地狱问题。

1. Promise的状态一经改变就不能再改变。
2. .then和.catch都会返回一个新的Promise。
3. catch不管被连接到哪里，都能捕获上层未捕捉过的错误。
4. 在Promise中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如return 2会被包装为return Promise.resolve(2)。 
5. Promise 的 .then 或者 .catch 可以被调用多次, 但如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用.then或者.catch的时候都会直接拿到该值。
6. .then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。
7. .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。
8. .then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。
9. .then方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为catch是.then第二个参数的简便写法。
10. .finally方法也是返回一个Promise，他在Promise结束的时候，无论结果为resolved还是rejected，都会执行里面的回调函数。
11. .finally()方法的回调函数不接受任何的参数，在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的
12. 它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。
13. Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。
14. .race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。
15. Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。
16. all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。

### null 和 undefined 区别
- null 表示空，此处不应该有值；而 undefined 表示未定义，变量声明了未赋值就是 undefined。
- 转换数字结果不同。Number(null)为0，undefined 为 NaN。
- null 是对象原型链终点

### 点击一个input依次触发的事件
`
'onmouseenter'
'onmousedown'
'onfocus'
'onclick'
`

### 闭包是什么
每个函数都有对应的词法环境，记录了变量和对外部词法环境引用。代码要访问变量时，会先搜索内部词法环境，找不到再搜索外部环境，直至全局词法环境。

闭包就是利用了这个特点，在函数内部保存了变量。闭包返回了嵌套函数，保留了对内部变量的引用，所以内部词法环境不会被删除。
### 设计一个不能操作 DOM 和调接口的环境
实现思路：

1）利用 iframe 创建沙箱，取出其中的原生浏览器全局对象作为沙箱的全局对象

2）设置一个黑名单，若访问黑名单中的变量，则直接报错，实现阻止/隔离的效果

3）在黑名单中添加 document 字段，来实现禁止开发者操作 DOM

4）在黑名单中添加 XMLHttpRequest、fetch、WebSocket 字段，实现禁用原生的方式调用接口

5）若访问当前全局对象中不存在的变量，则直接报错，实现禁用三方库调接口

6）最后还要拦截对 window 对象的访问，防止通过 window.document 来操作 DOM，避免沙箱逃逸

#### 实现
with对于沙箱的意义：可以实现所有变量均来自可靠或自主实现的上下文环境，而不会从全局的执行环境中取值，相当于做了一层拦截，实现隔离的效果

```javascript
// 沙箱全局代理对象类
class SandboxGlobalProxy {
  constructor(blacklist) {
    // 创建一个 iframe 标签，取出其中的原生浏览器全局对象作为沙箱的全局对象
    const iframe = document.createElement("iframe", { url: "about:blank" });
    iframe.style.display = "none";
    document.body.appendChild(iframe);

    // 获取当前HTMLIFrameElement的Window对象
    const sandboxGlobal = iframe.contentWindow;

    return new Proxy(sandboxGlobal, {
      // has 可以拦截 with 代码块中任意属性的访问
      has: (target, prop) => {

        // 黑名单中的变量禁止访问
        if (blacklist.includes(prop)) {
          throw new Error(`Can't use: ${prop}!`);
        }
        // sandboxGlobal对象上不存在的属性，直接报错，实现禁用三方库调接口
        if (!target.hasOwnProperty(prop)) {
          throw new Error(`Not find: ${prop}!`);
        }

        // 返回true，获取当前提供上下文对象中的变量；如果返回false，会继续向上层作用域链中查找
        return true;
      }
    });
  }
}

// 使用with关键字，来改变作用域
function withedYourCode(code) {
  code = "with(sandbox) {" + code + "}";
  return new Function("sandbox", code);
}

// 将指定的上下文对象，添加到待执行代码作用域的顶部
function makeSandbox(code, ctx) {
  withedYourCode(code).call(ctx, ctx);
}

// 待执行的代码code，获取document对象
const code = `console.log(document)`;

// 设置黑名单
const blacklist = ['window', 'document', 'XMLHttpRequest', 'fetch', 'WebSocket', 'Image'];

// 将globalProxy对象，添加到新环境作用域链的顶部
const globalProxy = new SandboxGlobalProxy(blacklist);

makeSandbox(code, globalProxy);
```

## 浏览器
### 在项目中如何把http的请求换成https
添加以下标签，浏览器会将网页内发送的 http 请求都改为 https。

```html
<meta http-equiv ="Content-Security-Policy" content="upgrade-insecure-requests">
```

### 说说事件流
事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个阶段。事件捕获阶段，目标阶段，事件冒泡阶段

通过addEventListener监听事件，第三个参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。

W3C DOM标准可以分为DOM1,DOM2,DOM3三个版本。DOM0就是直接通过 onclick写在html里面的事件，DOM2是通过addEventListener绑定的事件, 还有IE下的DOM2事件通过attachEvent绑定; DOM3是一些新的事件。

### 如何让事件先冒泡后捕获
在 DOM 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。 

### 事件委托
事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。 

相比起为每个子元素增加事件处理函数有性能优势，而且动态添加的子元素触发的事件也能被处理。

### 说一下图片的懒加载和预加载
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。

懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。

### JS 的 new 操作符做了哪些事
new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。 

### clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？ 
- clientHeight：表示的是可视区域的高度，不包含 border 和滚动条
- offsetHeight：表示可视区域的高度，包含了 border 和滚动条
- scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。
- clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0
- scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。 

### 如何理解前端模块化 
前端模块化就是将复杂的文件变成一个一个独立的模块，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了 commonJS 规范，AMD，CMD 规范等等，以及用于 JS 打包（编译等处理）的工具 webpack

### fetch 发送 2 次请求的原因
fetch 的 post 请求会先发送一次 options 请求，判断服务器是否支持，通过后才真正发送 post 请求。

### Cookie、sessionStorage、localStorage 的区别
共同点：都是保存在浏览器端，并且是同源的

不同点：
1. cookie 数据始终自动在同源的 http 请求中携带，其余两者不会。
2. cookie 有 path 的概念，可以限制 cookie 只属于某个路径下。
3. cookie 存储大小有限制，大约4K。
4. cookie 只和设置 cookie 时的过期时间有关。sessionStorage 在当前浏览器窗口关闭前有效。localStorage 始终有效。
5. cookie 和 localStorage 在所有同源窗口中共享。

### cookie 如何防范 XSS 攻击
XSS（跨站脚本攻击）是指攻击者在返回的 HTML 中嵌入 javascript 脚本。

在 HTTP 头部配上，set-cookie：

httponly - 这个属性可以防止 XSS,它会禁止 javascript 脚本来访问 cookie。

secure - 这个属性告诉浏览器仅在请求为 https 的时候发送 cookie。

### cookie 如何防范 csrf 攻击
CSRF：跨站请求伪造。需要用户已登录状态的cookie，在恶意网站中发起对目标网站的请求，浏览器发起请求时会携带对应域名的cookie。

防范措施：
- 服务器检测 origin header 和 Referer header
- 设置 cookie 的 same-site 属性。

### 说一下 web worker
在 HTML 页面中，脚本执行时，页面是不可响应的，脚本执行完成后，页面才恢复响应。web worker 是运行在后台的 js，不影响页面性能，运行结果通过 postMessage 回传到主线程。主线程监听 message 事件来拿到运行结果。

### 说一下 iframe
iframe 元素会创建包含另一个文档的内联框架。

缺点：
- 会阻塞主页面的 onload 事件。
- 搜索引擎无法解析，不利于SEO。
- iframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。

### Doctype 作用
`<!DOCTYPE html>`作用是启用标准模式。而怪异模式是向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。

### 说一下RESTFUL
用 URL 定位资源，用 HTTP 描述操作。

### 从输入URL到浏览器显示发生了什么
浏览器查找当前 URL 是否存在缓存，如果有缓存、并且缓存未过期，直接从缓存中返回。

查看域名是否已经被解析过了，没有解析过进行 DNS 解析将域名解析成 IP 地址，并增加端口号

如果请求是 HTTPS，进行 SSL 协商

利用 IP 地址进行寻址，请求排队。同一个域名下请求数量不能多余 6 个。

排队后服务器创建 TCP 链接 （三次握手）

发送 HTTP 请求

HTTP 1.1 中支持 keep-alive 属性, TCP 链接不会立即关闭，后续请求可以省去建立链接时间。

服务器响应结果状态码为 301、302 时，浏览器会进行重定向操作。（重新进行导航），返回 304 则查找缓存。

浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手。

浏览器检查响应状态码，如果资源可缓存，进行缓存。

当服务端返回的类型是 text/html 时，浏览器会边下载边解析

在解析前会执行预解析操作，会预先加载 JS、CSS 等文件。

构建 DOM 树

构建 CSSOM 树

根据 DOM 树和 CSSOM 树构建渲染树

遇到 JS 的解析过程：

HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。

当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载

所有 defer 脚本会按照在文档出现的顺序执行，在 HTML 被构建完成时执行

浏览器在 Document 对象上触发 DOMContentLoaded 事件

此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行 window 触发 load 事件

#### 通过 network Timing 观察请求发出的流程
Queuing: 请求发送前会根据优先级进行排队，同时每个域名最多处理 6 个 TCP 链接，超过的也会进行排队，并且分配磁盘空间时也会消耗一定时间。

Stalled: 请求发出前的等待时间（处理代理，链接复用）

DNS lookup: 查找 DNS 的时间

initial Connection: 建立 TCP 链接时间

SSL: SSL 握手时间（SSL 协商）

Request Sent: 请求发送时间（可忽略）

Waiting(TTFB): 等待响应的时间，等待返回首个字符的时间

Content Dowloaded: 用于下载响应的时间

![img.png](/img/networktimeing.png)

#### Performance 网页渲染绘制分析
Parse Html

Recalculated Style

Layout

Paint

Composite Layers

引入 CSS 文件后，会有 Parse Stylesheet 的过程。

因为解析是从上到下的，所以如果把 CSS 文件放在页面底部，已经绘制过一次之后也会解析样式，然后重新绘制一次。

此外，内联的 script 代码会阻塞 html 的解析和加载。导致 Parse html 的时间增加。

### 浏览器的渲染
浏览器渲染大致分为五步，创建 DOM 树，创建 CSSOM(CSS Object Model)，创建 layout 树，创建图层树和绘制 Painting。
1. 分析 HTML 元素，构建一颗 DOM 树。
2. 分析 css 文件和元素内联样式，生成CSSOM。css 的解析是从右往左逆向解析的。
3. 将 DOM 树和 CSSOM 关联起来，构建一颗 layout 树，确定每个节点的坐标位置。
4. 浏览器根据 layout 树进行分层，生成图层树。
5. 将不同图层进行绘制，转交给合成线程处理。最终生成页面，并显示到浏览器上

#### 浏览器渲染优化方式
- 区分优先级，异步、延迟加载请求减少渲染时间
- 减少请求数量和体积
- 可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是 CPU 上绘制屏幕的一部分来提高渲染性能，从而释放主线程。但是它以内存管理为代价，不能过度使用。有一些特定的属性和元素可以实例化一个层，包括 `<video>` 和 `<canvas>`，任何 CSS 属性为 opacity 、3D transform、will-change 的元素。

#### 回流（重排）和重绘
回流会触发重新绘制和重新排列。由于DOM的结构发生了改变，所以需要从生成DOM这一步开始，重新经过样式计算、生成布局树、建立图层树、再到生成绘制列表以
及之后的显示器显示这整一个渲染过程走一遍，开销是非常大的。

什么时候会触发 Layout(reflow) 呢？一般来说，当元素位置发生变化时就会。但也不尽然，因为浏览器会自动合并更改，在达到某个数量或时间后，会合并为一次 reflow

但某些代码会导致浏览器的这个优化失效，没有合并 reflow。这一般出现在我们用 js API 访问某个元素尺寸时，为了保证拿到的是精确值，不得不提前触发一次
reflow，即便写在 for 循环里。

当然也不是每次访问元素位置都会触发 reflow，在浏览器触发 reflow 后，所有已有元素位置都会记录快照，只要不再触发位置等变化，第二次开始访问位置就不会触发 reflow

这个 ”触发位置等变化“，一共有这么几类：

**获得盒子模型信息**
* 读取 `offset`、`scroll` 和 `client` 族属性时。elem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight, elem.offsetParent. elem.clientLeft, elem.clientTop, elem.clientWidth, elem.clientHeight
* elem.getClientRects(), elem.getBoundingClientRect(), window.getComputedStyle. getComputedStyle 通常会导致重排和重绘，是否触发重排取决于是否访问了位置相关的 key 等因素。
* 当改变元素的几何属性时 
* DOM 元素增减移动

获取元素位置、宽高的一些手段都会导致 reflow，不存在绕过一说，因为只要获取这些信息，都必须 reflow 才能给出准确的值。

**滚动**
* elem.scrollBy(), elem.scrollTo()
* elem.scrollIntoView(), elem.scrollIntoViewIfNeeded()
* elem.scrollWidth, elem.scrollHeight
* elem.scrollLeft, elem.scrollTop 访问及赋值

对 scrollLeft 赋值等价于触发 scrollTo，所有导致滚动产生的行为都会触发 reflow

**一些其他 element API**：
* elem.focus() (源码)
* elem.computedRole, elem.computedName
* elem.innerText (源码)
* inputElem.select()
* textareaElem.select()

**获取 window 信息**
* window.scrollX, window.scrollY
* window.innerHeight, window.innerWidth
* window.visualViewport.height / width / offsetTop / offsetLeft (源码)

和元素级别一样，为了拿到正确宽高和位置信息，必须重排。

**document 相关**
* document.scrollingElement 仅重绘
* document.elementFromPoint

elementFromPoint 因为要拿到精确位置的元素，必须重排。

**鼠标事件相关**
* mouseEvt.layerX, mouseEvt.layerY, mouseEvt.offsetX, mouseEvt.offsetY (源码)

鼠标相关位置计算，必须依赖一个正确的排布，所以必须触发 reflow。

**Range 相关**
* range.getClientRects(), range.getBoundingClientRect()

获取选中区域的大小，必须 reflow 才能保障精确性。

**SVG**
* 大量 SVG 方法会引发重排，就不一一枚举了，总之使用 SVG 操作时也要像操作 dom 一样谨慎。

**contenteditable**
* 被设置为 contenteditable 的元素内，包括将图像复制到剪贴板在内，大量操作都会导致重排。(源码)

##### 实践
现代浏览器会将多次 dom 操作合并，但像 IE 等其他内核浏览器就不保证有这样的实现了，因此给出了一个安全写法：

1. 不要一个属性一个属性的修改，用一次 className 的修改，或一次 cssText 的修改保证浏览器一定触发一次重排。

但这样可维护性会降低很多，不太推荐。

2. 读写分离

```javascript
function resizep () {
  for (var i = 0; i < p.length; i++) {
    p[i].style.width = box.offsetWidth + 'px';
  }
}
```

在 for 循环中不断访问元素宽度，并修改其宽度，会导致浏览器执行 N 次 reflow。

虽然当 JavaScript 运行时，前一帧中的所有旧布局值都是已知的，但当你对布局做了修改后，前一帧所有布局值缓存都会作废，因此当下次获取值时，不得不重新触发一次 reflow。

而读写分离的话，就代表了集中读，虽然读的次数还是那么多，但从第二次开始就可以从布局缓存中拿数据，不用触发 reflow 了。

相关库：fastdom

3. flex 布局比传统 float 重排速度快很多

重绘是重新绘制元素。当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)。当发生重绘的时候，会跳过生成布局树和建立图层树的阶段，直接绘制。

如何避免回流和重绘：
- 避免频繁使用 style，而是采用修改class的方式。
- 将动画效果应用到position属性为absolute或fixed的元素上。
- 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘
- 使用createDocumentFragment进行批量的 DOM 操作。
- 对于 resize、scroll 等进行防抖/节流处理。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 利用 CSS3 的transform、opacity、filter这些属性可以实现合成的效果，也就是GPU加速。
- 预先指定图片大小

### 渲染进程下的线程
- GUI渲染线程：负责渲染浏览器界面，解析html,css,DOM Tree, render Tree ，layout,绘制等
- js引擎线程：解析js脚本，运行代码
- 事件触发线程：用于控制事件轮询，鼠标点击，AJAX异步请求等，对应任务会被添加到事件触发线程中，符合触发条件时，事件会被添加到任务队列等待JS引擎处理
- 定时器触发线程：定时器setInterval 和 setTimeout
- http请求线程：用于http请求

### v8的垃圾回收
将内存分为了 new space 和 old space。

#### new space
new space 分为 from space 和 to space。

回收算法：

首先v8引擎检测到 from space 空间快达到上线了，就会进行垃圾回收。

其次从根部开始遍历，不可达对象被标记，可达对象被复制到 to space。

最后清除 from space 数据，将 to space变成 from space，from space 变成 to space。

可达对象会被放到 old space中的 old object space。

#### old space
old space 分为以下几个区域：
- old object space。新生代晋升来的
- large object space。大对象存储区域。
- map space。存储对象映射关系。
- code space。存放编译后代码的地方。

回收算法：
从根部对象深度有限遍历标记，标记完成后等待垃圾回收器清理。清除了以后如果新生代对象被放到 old object space 时内存不足，就会触发 mark-compact，释放内存空间。

### click 在 ios 上有 300ms 延迟，原因及如何解决？
1. 禁用缩放

```
<meta name="viewport" content="width=device-width, user-scalable=no">
```
2. fastclick
检测到 touchend 事件后，立刻出发模拟 click 事件，并且把浏览器 300 毫秒之后真正触发的事件给阻断掉

## 网络
### HTTPS
#### 工作流程
HTTPS主要是采用对称密钥加密和非对称密钥加密组合而成的混合加密机制进行传输。

也就是发送密文的一方用"对方的公钥"进行加密处理"对称的密钥"，然后对方在收到之后使用自己的私钥进行解密得到"对称的密钥"，这在确保双发交换的密钥是安全的前提下使用对称密钥方式进行通信。

这个过程简单来说就是：
* 客户端首先向服务端发送一个HTTPS请求
* 服务端会把事先配置好的公钥证书随着其它的信息返回给客户端
* 客户端在收到服务端发来的证书之后进行验证，验证的过程参考数字证书验证，会得到服务端的信息以及它的公钥
* 验证成功之后生成一个叫做 client_params 的参数发送给服务器；同时自己会用伪随机函数生成一个 secret，这个secret就是它们后续进行通信的对称密钥。
* 服务器在收到刚刚的 client_params之后，也会根据伪随机函数生成一个secret。这时候双方都有了相同的对称密钥。
* 后面的传输都会用这个 secret 进行对称密钥加解密传输

#### 对称密钥加密和非对称密钥加密有什么区别
对称密钥加密是最简单的一种加密方式，它的加解密用的都是相同的密钥，这样带来的好处就是加解密效率很快，但是并不安全。

而非对称密钥会有两把密钥，一把是私钥，只有自己才有；一把是公钥，可以发布给任何人。并且用一把密钥加密的内容只有另外一把密钥才能解。这样带来的一个好
处就是能保证传输的内容是安全的。但是非对称加密数据传输效率相对低了。

#### 混合加密好处
对称密钥加密和非对称密钥加密都有它们各种的优缺点，而混合加密机制就是将两者结合利用它们各自的优点来进行加密传输。

对称密钥优点是加解密效率高，那么客户端和服务器确定连接后就可以用它进行数据传输，前提是双方安全地拿到这把对称密钥。这时候可以用非对称加密来传输对称密钥，
因为非对称加密优点是保证安全传输内容。

所以好处是比单纯的非对称加密通信传输效率高，还解决了 HTTP 中内容可能被窃听的问题。

#### 混合加密的缺点
混合加密主要是为了解决HTTP中内容可能被窃听的问题。但是它并不能保证数据的完整性，也就是说在传输的时候数据是有可能被第三方篡改的，比如完全替换掉，
所以说它并不能校验数据的完整性。如果需要做到这一点就需要使用到数字签名。

#### 什么是数字签名
数字签名的产生主要就是为了解决HTTP中内容可能被篡改的问题，即校验数据的完整性。它能确定消息是发送方发送过来的，因为这里会有一个验证数字签名的过程，
别人是假冒不了发送方的签名的。

数字签名它是什么呢？它的产生过程其实就是两步，第一步将原文用Hash函数生成一个叫消息摘要的东西，第二步就是用发送方的私钥对这个消息摘要进行进行加密。
这个产生的东西就叫做数字签名，它一般会与原文一起发送给接收者。

而验证它的过程其实也并不复杂。
* 首先发送方会将原文与数字签名(也就是加密后的摘要)一起发送给接收方
* 接收方会接收到这两样东西，即原文和数字签名
* 接收方用Hash函数处理原文会得到一份消息摘要
* 同时用发送方的公钥解密数字签名也会得到一份消息摘要
* 只要比较这两份消息摘要是否相等就可以验证出数据有没有被篡改了

当然这里关键的一步就是要保证发送方传递过来的公钥是可信赖的，这时候就得用到数字证书了。

#### 数字证书
数字证书也叫公钥证书。它主要是为了解决通信方身份遭伪装的问题，也就是验证通信方的身份。

因为我们知道在HTTPS中虽然有了混合加密机制保证数据不被监听，有了数字签名校验数据的完整性，但是数字签名校验的前提是能拿到发送方的公钥，并且保证这个
公钥是可信赖的，所以就需要数字证书。

它简单来说其实是由一些权威的数字认证机构颁发给服务器的一个文件。数字认证机构简称CA，它是客户端和服务端都信任的第三方机构，我知道比较有名的一个就是
威瑞信(VeriSign)。至于颁发证书的流程，主要是为：

* 服务器的运营人员会向认证机构提交自己的公钥、组织信息、个人信息等并申请认证
* 而认证机构在拿到这些信息后会通过线上、线下各种途径验证申请者提交信息的真实性
* 在确认其真实性后，认证机构给这些信息(申请者的公钥，组织信息，个人信息以及认证机构自己的信息等)，我们简称为明文信息，进行数字签名，过程也就是签名提到的数字签名的步骤：1.通过Hash函数处理明文信息生成一个信息摘要；2.再用认证机构自己的私钥对信息摘要进行加密处理。通过这两个步骤生成的文件就叫数字签名。
* 之后会将明文信息和数字签名组合而成的证书颁发给申请者，也就是服务器。

#### 为什么说数字证书就能对通信方的身份进行验证呢？
那是因为在客户端第一次给服务端发送HTTPS请求的时候，服务端会将它自己的证书随着其它的信息(例如server_random、 server_params、需要使用的加密套件等东西)一起返给客户端。

客户端在收到之后首先会验证这个证书，只有验证通过之后才会有后续操作。而验证的过程其实也就是数字签名的验证过程：

* 前面说过了，证书其实是由明文信息(申请者的公钥，组织信息，个人信息以及认证机构自己的信息等)和这个明文信息的数字签名组成的。(对应着题5也就是原文和数字签名)
* 客户端会用Hash函数处理明文信息生成一个信息摘要
* 然后再用内置在浏览器上的CA的公钥来解密证书里的数字签名，得到一个信息摘要。因为我们知道证书实际是由CA颁发给服务器的，并且里面的数字签名也是用的CA的私钥加密的，所以只有CA的公钥才能解。
* 最后再将两个信息摘要进行对比，若是一样则能保证通信方的身份是正确的。

其实验证证书的过程不仅仅是数字签名的验证，客户端还会验证证书相关的域名信息，有效时间，是不是在CRL吊销列表里，以及它的上一级是否有效等等。

#### 请详细的说一下HTTPS它的加密传输过程，涉及到哪些算法呢？
在HTTPS加密传输中，实际上涉及到 SSL/TLS 协议，这里是有一个TSL握手的过程。对于传统的TLS握手也就是RSA握手我就不描述了，主要是说一下现在主流的TLS1.2版本的握手，也就是ECDHE握手。

它的过程大致来说是这样的：
1. 客户端在第一次发送HTTPS请求的时候，会把 client_random、TSL版本号、加密套件列表发送给服务器

2. 服务器在接收到之后确认TSL的版本号，同时发送 server_random、server_params、需要使用的加密套件、以及自己的证书给客户端

3. 客户端在收到这些信息之后，首先是会对服务器的证书进行验证(也就是题目7)，若是验证成功则会传递一个 client_params 给服务器

4. 与此同时客户端会通过ECDHE算法计算出一个pre_random，其中是传入了两个参数，一个是 client_params，还一个是 server_params。(也就是说：ECDHE(client_params, server_params) = per_random)

5. 这时候客户端就同时拥有了 client_random、server_random、pre_random，它会将这三个参数通过一个伪随机函数计算得出最终的secret，这个secret就是它们后续通信所要用的对称密钥。

6. 而在客户端生成完secret之后，会给服务器发送一个收尾消息，告诉服务器之后都要用对称加密，且对称加密的算法是用第一次约定好的。

7. 服务器它在接收到刚刚传递过来的client_params之后，也会使用和客户端一样的方式生成secret，并且也会发送一个收尾消息给客户端。

8. 当双方都收到收尾消息并验证成功之后，握手就结束了。后面开始用这个secret对称密钥加密报文进行传输。

#### RSA握手
1. 客户端首先向服务端发送一个HTTPS请求
2. 服务端会把事先配置好的公钥证书随着其它的信息返回给客户端
3. 客户端在收到服务端发来的证书之后进行验证，验证的过程参考数字证书验证，会得到服务端的信息以及它的公钥
4. 验证成功之后会用伪随机函数计算出一个加密所需要的对称密钥(secret)，并且用服务端的公钥加密这个对称密钥发送给服务端
5. 服务端再用自己的私钥解密刚刚的消息，得到里面的对称密钥。此时服务端和客户端都有了对称密钥。
6. 后面的传输都会用这个 secret 进行对称密钥加解密传输

#### 详细描述RSA握手
1. 客户端首先发送 client_random、TSL版本号、加密套件列表给服务器
2. 服务器在接收到之后确认TSL版本号，同时发送server_random、需要使用的加密套件、自己的证书给客户端
3. 客户端在收到这些信息之后，首先是会对服务器的证书进行验证(也就是题目7)，若是验证成功则会用RSA算法生成一个pre_random，且用服务器的公钥(在证书中)加密pre_random发送给服务器。
4. 此时，客户端有了 client_random、server_random、pre_random，它会将这三个参数通过一个伪随机函数计算得出最终的secret，这个secret就是它们后续通信所要用的对称密钥。
5. 服务器接收到了刚刚用自己公钥加密的pre_random之后，用自己的私钥进行解密，得到里面的 pre_random，用和客户端一样的方式生成secret。
6. 之后就用这个 secret对称密钥加密报文传输。

#### ECDHE握手和RSA握手又有什么区别呢
它们的区别主要是：

1. 生成secret(对称密钥)的过程不同。RSA中是使用RSA算法生成一个pre_random并用服务器的公钥加pre_random发送给服务器，然后各自用伪随机函数生成相同的secret对称密钥；而在ECDHE握手中，它没有用到RSA算法，而是用ECDHE算法生成的pre_random，且这个过程中比RSA多了client_params和server_params两个参数。
2. 在生成完secret之后，ECDHE握手在客户端发送完收尾消息后可以提前抢跑，直接发送 HTTP 报文，节省了一个 RTT，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫TLS False Start。
3. 最主要的：RSA不具备向前安全性，ECDHE有

（向前安全性：一次破解并不影响历史信息的性质就是向前安全性）

#### 向前安全性
一句话概括：一次破解并不影响历史信息的性质就是向前安全性。

比如在RSA握手的过程中，客户端拿到了服务端的公钥，然后用此公钥加密pre_random给服务端。如果此时有第三方有服务端的私钥，并且截获了之前所有报文的时候，那么它就可以破解这段密文并拿到pre_random、client_random、server_random并根据对应的伪随机函数生成secret，即拿到了最终通信的对称密钥，每一个历史报文都能通过这样的方式进行破解。它就不具有向前安全性。

但是ECDHE在每次握手的时候都会产生一个零时的密钥对(也就是client_params、server_params)，即使第三方有了私钥能破解，但是对之前的历史报文并没有影响。它就具有向前安全性。

### node实现websocket
```
//ws.js
const { EventEmitter } = require('events');
const http = require('http');
const crypto = require('crypto');

function hashKey(key) {
  const sha1 = crypto.createHash('sha1');
  sha1.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
  return sha1.digest('base64');
}

function handleMask(maskBytes, data) {
  const payload = Buffer.alloc(data.length);
  for (let i = 0; i < data.length; i++) {
    payload[i] = maskBytes[i % 4] ^ data[i];
  }
  return payload;
}

const OPCODES = {
  CONTINUE: 0,
  TEXT: 1,
  BINARY: 2,
  CLOSE: 8,
  PING: 9,
  PONG: 10,
};

function encodeMessage(opcode, payload) {
  //payload.length < 126
  let bufferData = Buffer.alloc(payload.length + 2 + 0);;
  
  let byte1 = parseInt('10000000', 2) | opcode; // 设置 FIN 为 1
  let byte2 = payload.length;

  bufferData.writeUInt8(byte1, 0);
  bufferData.writeUInt8(byte2, 1);

  payload.copy(bufferData, 2);
  
  return bufferData;
}

class MyWebsocket extends EventEmitter {
  constructor(options) {
    super(options);

    const server = http.createServer();
    server.listen(options.port || 8080);

    server.on('upgrade', (req, socket) => {
      this.socket = socket;
      socket.setKeepAlive(true);

      const resHeaders = [
        'HTTP/1.1 101 Switching Protocols',
        'Upgrade: websocket',
        'Connection: Upgrade',
        'Sec-WebSocket-Accept: ' + hashKey(req.headers['sec-websocket-key']),
        '',
        ''
      ].join('\r\n');
      socket.write(resHeaders);

      socket.on('data', (data) => {
        this.processData(data);
        // console.log(data);
      });
      socket.on('close', (error) => {
          this.emit('close');
      });
    });
  }

  handleRealData(opcode, realDataBuffer) {
    switch (opcode) {
      case OPCODES.TEXT:
        this.emit('data', realDataBuffer.toString('utf8'));
        break;
      case OPCODES.BINARY:
        this.emit('data', realDataBuffer);
        break;
      default:
        this.emit('close');
        break;
    }
  }

  processData(bufferData) {
    // Reads an unsigned 8-bit integer from buf at the specified offset.
    const byte1 = bufferData.readUInt8(0);
    let opcode = byte1 & 0x0f; 
    // 第一位是 mask 标志位，后 7 位是 payload 长度。
    const byte2 = bufferData.readUInt8(1);
    const str2 = byte2.toString(2);
    const MASK = str2[0];

    let curByteIndex = 2;
    
    let payloadLength = parseInt(str2.substring(1), 2);
    if (payloadLength === 126) {
      payloadLength = bufferData.readUInt16BE(2);
      curByteIndex += 2;
    } else if (payloadLength === 127) {
      payloadLength = bufferData.readBigUInt64BE(2);
      curByteIndex += 8;
    }

    let realData = null;
    
    if (MASK) {
      const maskKey = bufferData.slice(curByteIndex, curByteIndex + 4);  
      curByteIndex += 4;
      const payloadData = bufferData.slice(curByteIndex, curByteIndex + payloadLength);
      realData = handleMask(maskKey, payloadData);
    } 
    
    this.handleRealData(opcode, realData);
  }

  send(data) {
    let opcode;
    let buffer;
    if (Buffer.isBuffer(data)) {
      opcode = OPCODES.BINARY;
      buffer = data;
    } else if (typeof data === 'string') {
      opcode = OPCODES.TEXT;
      buffer = Buffer.from(data, 'utf8');
    } else {
      console.error('暂不支持发送的数据类型')
    }
    this.doSend(opcode, buffer);
  }

  doSend(opcode, bufferDatafer) {
    this.socket.write(encodeMessage(opcode, bufferDatafer));
  }
}

module.exports = MyWebsocket;
```

```
const MyWebSocket = require('./ws');
const ws = new MyWebSocket({ port: 8080 });

ws.on('data', (data) => {
  console.log('receive data:' + data);
  setInterval(() => {
    ws.send(data + ' ' + Date.now());
  }, 2000)
});

ws.on('close', (code, reason) => {
  console.log('close:', code, reason);
});
```
```
<!DOCTYPE HTML>
<html>
<body>
    <script>
        const ws = new WebSocket("ws://localhost:8080");

        ws.onopen = function () {
            ws.send("发送数据");
            setTimeout(() => {
                ws.send("发送数据2");
            }, 3000)
        };

        ws.onmessage = function (evt) {
            console.log(evt)
        };

        ws.onclose = function () {
        };
    </script>
</body>

</html>
```

## 资料
[CSS 拷问：水平垂直居中方法你会几种？](https://liuyib.github.io/2020/04/07/css-h-and-v-center/)

[CSS灵感](https://csscoco.com/inspiration/)

[面试官：请设计一个不能操作 DOM 和调接口的环境](https://juejin.cn/post/7157570429928865828)

[用nodejs手写websocket](https://mp.weixin.qq.com/s/EWE6vIvwWDJ_A6SqikV6Tg)

[chrome浏览器渲染进程工作流程](https://juejin.cn/post/6962087948112101383)

