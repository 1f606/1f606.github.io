---
layout:     post
title:      Vue3
subtitle:   
date:       2023-2-24
author:     
header-img:
catalog: true
tags:
- Vue
---
# Vue3
## setup
要在组件模板中使用响应式状态，需要在 setup() 函数中定义并返回。
```javascript
export default {
  setup () {
    const state = reactive({num: 0});
    return {
      // 暴露到模板的变量
    };
  }
}
```

### 选项参数
1. props。解构后失去响应式，使用 toRefs() 和 toRef() 将可以某个 prop 传到一个外部函数中并保持响应性。
2. Setup。setup 函数的第二个参数是一个 非响应式的 Setup 上下文对象，可以安全地解构。其中attrs 和 slots 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性。
   和 props 不同，attrs 和 slots 的属性都不是响应式的。如果你想要基于 attrs 或 slots 的改变来执行副作用，那么你应该在 onBeforeUpdate 生命周期钩子中编写相关逻辑。

## script setup
`<script setup>`，省去了暴露状态和方法的繁琐操作。顶层的绑定会被暴露给模板。

与普通的 `<script>` 只在组件被首次引入的时候执行一次不同，<script setup> 中的代码会在组件创建之前, props 被解析之后执行。在 setup 中你应该
避免使用 this，因为它不会找到组件实例。

### 顶层的绑定会被暴露给模板
当使用 `<script setup>` 的时候，任何在 `<script setup>` 声明的顶层的绑定 (包括变量，函数声明，以及 import 引入的内容) 都能在模板中直接使用：

```vue
<script setup>
// 变量
const msg = 'Hello!'

// 函数
function log() {
  console.log(msg)
}
</script>

<template>
  <div @click="log">{{ msg }}</div>
</template>
```

引用组件也能直接在模板中使用，强烈建议使用 PascalCase 格式以保持一致性。同时也有助于区分原生的自定义元素。

### props 和 emits
在 `<script setup>`中必须使用 defineProps 和 defineEmits API 来声明 props 和 emits

```vue
const props = defineProps({
foo: String
})

const emit = defineEmits(['change', 'delete'])
```

defineProps 接收与 props 选项相同的值，defineEmits 也接收 emits 选项相同的值。

传入到 defineProps 和 defineEmits 的选项会从 setup 中提升到模块的范围。因此，传入的选项不能引用在 setup 范围中声明的局部变量。
这样做会引起编译错误。但是，它可以引用导入的绑定，因为它们也在模块范围内。

## transition-group
`<transition-group>` 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素。

## 侦听
当侦听一个数组时，只有当数组被替换时才会触发回调。如果你需要在数组被改变时触发回调，必须指定 deep 选项

## template 标签
没有特殊指令的标记 (v-if/else-if/else、v-for 或 v-slot) 的 `<template>` 现在被视为普通元素，并将渲染为原生的 `<template>` 元素，而不是渲染其内部内容。

vue2中，当挂载一个具有 template 的应用时，被渲染的内容（传入的元素）会替换我们要挂载的目标元素。vue3，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML。

