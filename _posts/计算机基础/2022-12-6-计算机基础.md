---
layout:     post
title:      计算机基础
subtitle:   
date:       2022-12-6
author:     
header-img:
catalog: true
tags:
    - 计算机基础
---
## 计算机的简略发展史
### 电子管时代
背景：为了军方的计算要求，比如弹道轨迹计算，人们的需要一个能代替人脑的计算装置。

当时的计算机会有很多逻辑处理元件，它们在高低电压（可以表示01的二进制）下用线路连接起来实现计算的功能。

当时的主要逻辑元件是电子管，体积大，耗电量大。此时的计算机只能识别0101的二进制数，所以只能用机器语言来编程。

### 晶体管时代
背景：希望计算机体积、耗电量、计算能力等方面比上个时代更出色。

晶体管的电气特性可以替代电子管，而且晶体管的体积比电子管小很多，这也意味着此时的计算机要小很多。
并且出现了面向过程的程序设计语言和操作系统的雏形，制造一台计算机大概需要几万到几十万的晶体管，并且需要用手工的方式把晶体管焊接到电路板上，就非常容易出错。

### 中小规模集成电路时代
集成电路的技术让我们计算机变得越来越小，同时功耗更低，可靠性也比手动焊接的晶体管更高，
此时的计算机主要用于科学计算，一些高级语言同时产生，并出现分时操作系统

### 超大规模集成电路时代
随着集成电路工艺的不断提升，出现了大规模和超大规模集成电路，此时开始出现微处理和微型计算机，也就是我们现在家用的计算机，就拿苹果的A13处理器来说，每一个逻辑元件在其中不超过7纳米，一个指甲盖大小的cpu就集成了85亿个晶体管。

## 计算机的硬件组成
### 冯诺依曼体系
冯诺依曼就提出了存储程序的概念，将指令以二进制代码的形式事先输入到计算机的内存里，然后内存根据里面存储的指令从首地址也就是第一条指令开始按顺序一条一条的执行，直到程序执行结束，这种自动执行的机制比人工操作使计算机的计算效率大大提升。

冯诺依曼体系是以运算器为核心的，我们现代的计算机是以存储器为核心
### 现代计算机
首先，计算机最基本的5大组成部分分别为：输入设备(比如键盘), 存储器(比如内存), 运算器(cpu), 控制器(cpu), 输出设备(显示器)。

![img.png](/img/计算机硬件组成.png)

上图的实线是数据线，是数据交换的通路，虚线是控制线和反馈线，是传递命令的通路

- 首先我们的数据通过输入设备会被加工程计算机能够识别的0101的形式，我们直接输入的代码计算机是不认识的。
- 然后经过输入设备处理的数据，先存到了存储器里（控制器控制输入设备），存储器可以存放数据和程序指令
- 然后控制器可以直接从存储器里取得所需要执行的程序指令，取得指令后，控制器会分析指令要做什么（指令分为操作码和地址码），分析的就是操作码，到底要干嘛
- 假设分析出来是读取数据的操作，也就是从存储器中取一个数据给运算器，那么读取数据的地址就在写在地址码里面，这时运算器就去就告诉存储器要取数据的地址，然后存储器直接把数据传递给运算器
- 最后运算结束，运算结果会返回存储器，存储器可以直接把结果返回给输出设备（在控制器的控制下）
- 最后输出设备，比如显示器上就看到我们想要的数据

我们拿一个实际的javascript代码来举例:

假设在我们的JS代码里，运行代码 let a = 1 + 1，此时上述的5大计算机部件如何处理的呢？
- 首先键盘输入代码let a = 1 + 1将被解析为2进制代码，在控制器的控制下放入了内存
- 然后内存存储完毕， CPU的控制器开始从内存里取出指令，分析出指令是一个加法操作（先让 1+1运算，后面才会把1+1运算的结果赋值给变量a）
- 然后控制器控制运算器，运算器直接从内存里取出数据两个1，做一个加法运算得出结果，并返回给存储器，存储到一个内存的地址里
- 然后控制器接着执行第二条指令（let a = 2），因为之前2已经被算出来了，第二条指令是赋值操作了（把1+1的值赋给变量a，a其实就是一个内存地址而已）
- 此时CPU的控制将控制CPU的运算器做1+1的加法运算，并得出结果2
- 最后执行指令完毕，如果我们要打印console.log(a)的话，a因为本质上是一个内存地址，cpu会根据内存地址，找到这个地址里存放的值，也就是console.log显示的值
- 获取到要显示的值后，存储器直接将数据传给显示器，这样我们就可以在屏幕上看到2这个结果了

## 为什么计算机内部选择二进制数表示
- 技术实现简单，计算机是由逻辑电路组成，逻辑电路通常只有两个状态，开关的接通与断开，这两种状态正好可以用 “1” 和 “0” 表示;
- 易于进行转换，二进制与十进制数易于互相转换;
- 适合逻辑运算,逻辑代数是逻辑运算的理论依据，二进制只有两个数码，正好与逻辑代数中的“真”和“假”相吻合;

## JavaScript 与 IEEE 754
JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。

64位分为三个部分：
- 符号位：第1位是正负数符号位，0代表正数（大于等于0），1代表负数。
- 指数位：中间的11位存储指数
- 尾数位：最后的52位是尾数，代表有效数字，大于等于1小于2

## 真值和机器数
例如：

+15 => 01111（2进制）

-8 => 11000（2进制）

真值是我们平时生活中用到的数字形式，比如+15，-8。机器数是存到机器里的形式，也就是2进制的形式，其中01111，第一个0是代表正数的意思，1111是保存的数值，转换成10进制就是15，合起来就是+15。11000同理。

## 单位
计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)。

转换关系：

8位 = 1字节

1024字节 = 1K

1024K = 1M

1024M = 1G

1024G = 1T

## 编码
### ASCII
0-32种状态规定了特殊用途,接收到约定好的这些字节，就要做一些约定的动作。又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第 127 号，这样计算机就可以用不同字节来存储英语的文字了

这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。

### GB2312
西欧一些国家用的不是英文，它们的字母在ASCII里没有为了可以保存他们的文字，他们使用127号这后的空位来保存新的字母，一直编到了最后一位255。
从128 到 255 这一页的字符集被称为扩展字符集。在不同编码中表示的也不同。

中国为了表示汉字，把127号之后的符号取消了，规定：
一个小于127的字符的意义与原来相同，但两个大于 127 的字符连在一起时，就表示一个汉字；
前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从 0xA1 到 0xFE。
这样我们就可以组合出大约7000多个(247-161)*(254-161)=(7998)简体汉字了。
还把数学符号、日文假名和ASCII里原来就有的数字、标点和字母都重新编成两个字长的编码。这就是全角字符，127以下那些就叫半角字符。
把这种汉字方案叫做 GB2312。GB2312 是对 ASCII 的中文扩展

### GBK
不再要求低字节一定是 127 号之后的内码，只要第一个字节是大于 127 就固定表示这是一个汉字的开始,又增加了近 20000 个新的汉字（包括繁体字）和符号。
### Unicode
ISO 的国际组织废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符 的编码！ Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。
ISO 就直接规定必须用两个字节，也就是 16 位来统一表示所有的字符，对于 ASCII 里的那些 半角字符，Unicode 保持其原编码不变，只是将其长度由原来的 8 位扩展为16 位，而其他文化和语言的字符则全部重新统一编码。
从 Unicode 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的一个字符！同时，也都是统一的 两个字节
注意：字节是一个8位的物理存贮单元， 而字符则是一个文化相关的符号。
### 平面（Plane）
Unicode 使用的数字是从 0 到 0x10ffff，这些数字都对有相对应的字符（当然，有的还没有编好，有的用作私人自定义）。每一个数字，就是一个代码点（Code Point）。
这些代码点，分为 17 个平面（Plane）。其实就是17 组。
Plane 3 到 Plane 14 还没有使用。
Plane 0，习惯上称作基本平面（Basic Plane）；剩余的称作扩展平面（Supplementary Plane）。
### utf-32
UTF-32 使用四个字节来表示存储代码点：把代码点转换为 32 位二进制，位数不够的左边充 0。
4个字节就是4 * 8 = 32位，就能表示2的32次方个数字，这些数字可以对应2的32次方个字符
### utf-16
UTF-16 用二个字节来表示基本平面，用四个字节来表示扩展平面。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）
### utf-8
UTF-8是一种变长的编码方法，字符长度从1个字节到4个字节不等。 越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。

### 中文在unicode里面的范围
4E00~9FA5：中日韩统一表意文字 其余有需要自查。4E00－9FA5 就是一般正则表达式匹配中文的范围。

### 在javascript中，如何转utf8呢？
可以使用encodeURIComponent

平时我们说中文是两个字节表示的，这个是错误的，几个字节表示完全是看编码，比如utf8和utf16有可能同样的unicode码，编码出来的字节数是不一样的。 我们平时的页面都是utf8编码的，其实在底层2进制上，中文通常是3个字节表示的。

### JavaScript 如何在内部使用 Unicode
虽然 JavaScript 源文件可以有任何类型的编码，但 JavaScript 会在执行之前在内部将其转换为 UTF-16。
JavaScript 字符串都是 UTF-16 序列，正如 ECMAScript 标准所说： 当 String 包含实际文本数据时，每个元素都被视为单个 UTF-16 代码单元。

## 定点数和浮点数
![img.png](/img/定点数和浮点数.png)

### 定点数
#### 无符号数
就是整个机器字长的全部二进制位均为数值位，没有符号位，相当于都是正数。机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数，比如我们常说32位机器，64位机器。

比如8位无符号整数的范围就是 二进制： 00000000 - 11111111，转化为10进制就是0 - 255。

注意我们说的无符号数都是针对整数，没有小数。

#### 有符号数的定点表示
先来看看定点整数和定点小数如何在计算机里表示。
![image](https://user-images.githubusercontent.com/51157718/220058515-b25ffca7-db81-4fff-aeab-a32c80ab947f.png)

- 定点整数：符号位在第一位，通常0表示正数，1表示负数，小数点默认在最后一位，是隐藏的
- 定点小数：符号位在第一位，通常0表示正数，1表示负数，小数点隐藏在符号位后面，小数的数值部分也可以叫尾数，这个我们在浮点数介绍的时候会出现这个名词（数值部分 = 尾数）

定点数整数和小数都可以用原码，反码，补码表示，整数还可以用移码表示，具体什么意思我们稍后介绍。

#### 原码
原码就是用尾数表示真值的绝对值，符号位0表示正数，1表示负数。

假设我们机器字长为8位，我们拿 +19和 -19来解释一下。
![img.png](/img/+19和-19.png)

+19表示为：0，0010011 -19表示为: 1,0010011

下面是定点小数的表示：
![img.png](/img/+0.75和-0.75.png)

#### 反码
正数的反码 = 原码

负数的反码，则数值位全部取反，符号位不变

#### 补码
正数的补码 = 原码

负数的补码 = 反码 + 1

#### 移码
补码的基础上符号位取反，只能表示整数。为什么需要移码，移码可以非常方便地判断两个数的大小。如下图：

![img.png](/img/移码.png)

我们会发现移码从左往右，只要先有1就更大，如果都有1，就往后面比，先出来1的就更大

#### 为什么需要补码移码
比如我们做一个运算 14 + (-14)，按道理应该等于0，但是我们把它们转为2进制，定点数的加法就出现问题了，居然不等于0，如下图：
![img.png](/img/14+-14.png)

那该怎么办呢，原码的加法需要变为减法也就是14-14，这样就对了，但是这意味我们的计算机既要设计一个加法器又要设计一个减法器，减法器的复杂度是很高的，
为了方便运算，一些聪明的人实现了让加法代替减法，这就需要我们之前讲的补码知识了。

14 + （-14）怎么才能计算正确呢?

我们可以让14的原码 加上 -14的补码，这时候就是 00001110 + 11110010（这个是-14的补码） = 100000000，因为机器字长是8位，
也就是最多容纳8位2进制，最左边的1会被机器天然丢弃，这样最终结果就是00000000.

### 浮点数
定点数对于很大的数字是特别浪费空间的，所以需要浮点数。举个例子，比如说浮点数1.2 x 10的20次方，我们知道是10进制，就只需要存1.2和20这些数据就能表示这个数，
但是定点数一个数字占一个坑，肯定没有浮点数在更小的空间表示更大的数。

我们举一个例子来理解浮点数的表示，比如数字+302657264526，这是定点整数的表示方法，如果是科学计数法，我们表示为：+3.026 * 1011 ，而其中的10是不是固定不变的呢，
所以如果要保存这个科学技术法表示的数字，我们可以不看10这个基数，只需要保存+11 和 +3.026就能推出这个数字的科学技术法，从而得到这个数字

我们可以给+11 和 +3.026取两个名字，在浮点数里分别叫阶码和尾数，如下图：

![img.png](/img/浮点数表示.png)

注意阶码分为了阶符和阶码的数值部分，尾数分为数符和尾数的数值部分。

阶符是正表示小数点往后移，为负表示小数点往前移动。阶码表示小数点移动多少位。

数符表示数值的正负性，尾数表示数字精度。

其中， 阶码反映数值的大小，尾数反应数值的精度，为什么这么说呢，比如之前举的例子中，+11表示小数点要右移多少位，是不是越大，移动的位数越多，数字就越大呢，
对于尾数，比如+3.0265748是不是同样右移5位比+3.026表示的数字更精确呢

在二进制表示的计算机内，阶码常用补码或者移码表示的定点整数，尾数常用原码或者补码表示的定点小数。

浮点数的表示为 N = rE * M ， r相当于底数，是2（跟10进制科学计数法是10时意思是一样的），E代表阶码，M代表尾数。

## 不同进制的表示
有后缀和下标表示。如二进制：(10)B 和 (10)₂
八进制，十进制和十六进制的后缀分别是O, D, H。

## 不同进制的转换
1、任意进制转十进制。
- 每位数字乘以对应进制的位数次方后相加，位从0开始。例如：2进制的 101.1 = 1 x 2的2次方 + 0 x 2的1次方 + 1 x 2的0次方 + 1 x 2的-1次方
- JS：toString(radix)

2、十进制整数转为任意进制。
- 除商取余法。除对应进制。将余数由后往前拼接得到结果。
- JS：parseInt(num, radix);小数部分被截断。

例如：把89化为二进制的数：除二取余，倒序排列，高位补零。

89÷2=44 余1

44÷2=22 余0

22÷2=11 余0

11÷2=5 余1

5÷2=2 余1

2÷2=1 余0

1÷2=0 余1

结果：1011001

3、十进制小数转二进制小数

方式是采用“乘2取整，顺序排列”法。

1. 用2乘十进制小数，可以得到积，将积的整数部分取出-
2. 再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出-
3. 如此进行，直到积中的小数部分为零，或者达到所要求的精度为止

如: 十进制 0.25 转为二进制

0.25 * 2 = 0.5 取出整数部分：0

0.5 * 2 = 1.0 取出整数部分1

即十进制0.25的二进制为 0.01 ( 第一次所得到为最高位,最后一次得到为最低位)。

而0.1和0.2转换成二进制是无限循环的。所以0.1+0.2!==0.3

4、十进制份数转二进制
可以将分数拆分为更小的分数，将分数转为以2为底的负幂次方数的和，顺序是从大到小。转为二进制时，从2的负一次方开始找，看看和里面有没有这个数，没有的话对应二进制为0。

如53/64，2的负一次方是二分之一，2的负二次方是四分之一，2的负二次方是八分之一。可以分为32/64，16/64，4/64和1/64的和。对应着二进制(0.110101)₂

## JavaScript中的进制
### 进制表示
```
let a = 0b10100;//二进制
let b = 0o24;//八进制
let c = 20;//十进制
let d = 0x14;//十六进制
```
### 进制转换
- 10进制转任意进制 10进制数.toString(目标进制)
- 任意进制转十进制 parseInt('任意进制字符串', 原始进制)，小数部分会被截断;

## localhost 和 127.0.0.1
127.0.0.1是属于回环地址。回环地址会将所有发往该地址的数据包loop back。

localhost 是默认情况下都指向了 IPV4的 127.0.0.1 和 IPV6 的 ::1。

在hosts文件中可以指定给定域名对应的 IP 地址。

## 资料
[前端计算机基础大补丸在此！来一颗吧！](https://juejin.cn/post/7112318717798645768)
